---
title: "Fazendo um mapa de calor no R"
author: "Luis Otavio"
date: '2020-06-14'
image: images/post_principal/mg.png
slug: fazendo-um-mapa-de-calor-no-r
categories:
  - Caso prático
tags:
  - Maps
type: featured
---



<p>A missão dessa semana foi construir um <strong>mapa de calor no R</strong>!</p>
<p>Os mapas de calor representam a intensidade de uma medida nas áreas do mapa.</p>
<ul>
<li>Se quisermos utilizar o mapa de calor para mostrar as <strong>temperaturas de uma região</strong>, a coloração do mapa irá variar de acordo com a <strong>intensidade</strong> da temperatura.</li>
</ul>
<p>Também é comum usarmos mapas de calor nos esportes. Aqui, vou trazer uma aplicação no futebol.</p>
<ul>
<li>O mapa de calor de um jogador irá representar a <strong>intensidade de sua atuação</strong> em cada região do campo.</li>
</ul>
<p><strong>É fácil fazer um mapa de calor no R?</strong></p>
<p>Será muito fácil se você quiser fazer o mapa para um estado, cidade ou país. Nesse caso, os contornos da área que você deseja colocar no mapa já estarão definidos.</p>
<p>Porém, achei bem difícil fazer o mapa de calor para um atleta. A minha dificuldade foi delimitar por fórmulas os contornos de cada área do atleta.</p>
<p><strong>A seguir vou mostrar todo o código e explicar o passo a passo que usei para construir os mapas de calor.</strong></p>
<ul>
<li>Mapa de Calor do Estado de Minas Gerais:</li>
</ul>
<p><img src="/images/post_interno/minas_legenda.png" alt="Mapa de Calor - Minas Gerais" style="width:75.0%" />
- Mapa de Calor do Lateral Direito Victor Ferraz, no jogo Santos x Chapecoense pela 36ª rodada do Brasileirão 2019
<img src="/images/post_interno/mapacalor_lat_direito.png" alt="Mapa de Calor - Futebol" style="width:75.0%" /></p>
<div id="mapa-de-calor-do-estado-de-minas-gerais" class="section level3">
<h3>Mapa de Calor do estado de Minas Gerais</h3>
<p>Para construir um mapa de calor, vamos precisar dos seguintes elementos:</p>
<ul>
<li><p>Desenho da cidade, estado, país ou área para delimitar o gráfico</p></li>
<li><p>Valores da medida de intensidade</p></li>
<li><p>Coordenadas do mapa correspondente a cada ponto medido</p></li>
<li><p>Estrutura de polígonos para colorir de acordo com a intensidade medida</p></li>
</ul>
<p>O mapa de Minas Gerais já está desenhado pela biblioteca <code>geobr</code>, basta executar o seguinte script:</p>
<pre class="r"><code>library(geobr)
mg&lt;-read_state(code_state =&#39;MG&#39;)
#caso queira visualizar, basta executar plot(mg)</code></pre>
<p>O próximo passo é buscar os dados que possuem as coordenadas geográficas e a temperatura correspondente a cada ponto:</p>
<pre class="r"><code>library(readr)
temperatura_minasgerais &lt;- read_delim(&quot;content/blog/temperatura_minasgerais.txt&quot;, 
    &quot;\t&quot;, escape_double = FALSE, trim_ws = TRUE)</code></pre>
<p><a href="https://luisotavio.pro/blog/temperatura_minasgerais.txt" target="_blank">Dados disponíveis nesse link</a></p>
<p>O próximo passo é transformar o objeto <code>temperatura_minasgerais</code> para um formato adequado, já que vamos trabalhar com mapas.</p>
<p>Vamos utilizar a biblioteca <code>sf</code> para nos ajudar nesse desafio.</p>
<pre class="r"><code>library(sf)
temperatura_minasgerais.sf &lt;- st_as_sf(temperatura_minasgerais,coords = c(&#39;Longitude&#39;,&#39;Latitude&#39;),crs=4674) #o código 4674 é uma referência as coordenadas, esse é o código utilizado para o Brasil e outros países próximos.</code></pre>
<p>O passo seguinte é criar a estrutura do mapa para o estado de Minas Gerais. Essa estrutura será a base para futuramente preenchermos o nosso mapa.</p>
<pre class="r"><code>library(dplyr)
estrutura.mg &lt;-st_make_grid(mg,cellsize = c(.07,.07)) %&gt;% 
  st_as_sf() %&gt;%
  filter(st_contains(mg,.,sparse = FALSE))</code></pre>
<p>Uma observação importante é a definição do valor do parâmetro <em>cellsize</em>: quanto menor o tamanho o seu valor, menor será o tamanho de cada célula e <strong>melhor</strong> será a qualidade do gráfico, porém irá demorar mais tempo para a geração da imagem.</p>
<pre class="r"><code>plot(estrutura.mg)</code></pre>
<p><img src="/images/post_interno/grade_mg.png" alt="Grade - Minas Gerais" style="width:75.0%" />
Na imagem acima podemos ver que existem vários pontos no nosso mapa. Porém, não sabemos a temperatura para todos eles.</p>
<p>Então como fazemos para colorir o mapa se não sabemos as temperaturas para cada ponto?</p>
<p>Existem métodos que estimam a temperatura de um ponto baseando-se nas temperaturas dos pontos mais próximos.</p>
<p>Portanto, o nosso próximo passo é construir um modelo de previsão para os pontos que não temos o valor de temperatura.</p>
<pre class="r"><code>library(gstat)
modelo&lt;-gstat(formula = temp~1,
              data = as(temperatura_minasgerais.sf,&#39;Spatial&#39;),
              set=list(idp=3))</code></pre>
<p>Pronto. O modelo foi criado. Agora vamos gerar as previsões de temperatura baseadas neste modelo.</p>
<pre class="r"><code>temp.interpolacao &lt;- predict(modelo,as(estrutura.mg,&#39;Spatial&#39;)) %&gt;%
  st_as_sf()</code></pre>
<p>Pronto. Agora que já temos as temperaturas para todos os pontos do mapa, podemos criá-lo:</p>
<pre class="r"><code>library(ggplot2)
library(fields) #biblioteca para usar a paleta de cores tim.colors
ggplot(temp.interpolacao) + 
  geom_sf(aes(fill=var1.pred,col=var1.pred))+
  geom_sf(data=mg,fill=&#39;transparent&#39;)+
  scale_color_gradientn(colors = tim.colors(50),
                        limits=c(19,28))+
  scale_fill_gradientn(colors = tim.colors(50),
                        limits=c(19,28))+
  theme_bw()+
  labs(title = &quot;Dados Interpolados&quot;,
       fill =&#39;ºC&#39;,
       color= &#39;ºC&#39;)</code></pre>
<div class="figure">
<img src="/images/post_interno/minas_legenda.png" alt="Mapa de Calor - Minas Gerais" style="width:75.0%" />
<p class="caption">Mapa de Calor - Minas Gerais</p>
</div>
</div>
<div id="mapa-de-calor-no-futebol" class="section level3">
<h3>Mapa de Calor no Futebol</h3>
<p>Já vou começar ressaltando a maior diferença para fazer esse mapa de calor.</p>
<p>No caso anterior, para fazer um mapa de calor para o estado de Minas Gerais, já tínhamos o contorno do estado. Além disso, <strong>a ideia é colorir todo o estado</strong>.</p>
<p>E é aí que está a grande dificuldade para aplicar o mapa de calor no Futebol.</p>
<p>No segundo exemplo, podemos delimitar a área do jogador sendo a área de todo o campo de futebol. Porém, não podemos colorir todo o campo de futebol. Não faz nenhum sentido.</p>
<p>As informações que temos aqui nesse exemplo são as coordenadas (do eixo X e do eixo Y) de cada jogada do atleta. Ou seja, são pontos dentro do campo.</p>
<p>Colocar esses pontos no campo, é fácil. Porém, como delimitar as curvas de cada área utilizada pelo jogador?</p>
<p>Para resolver isso, usei a minha intuição e vou mostrar todo o raciocínio junto com o código.</p>
<div id="introdução" class="section level4">
<h4>Introdução</h4>
<ul>
<li>Para criar a estrutura onde vamos colorir a área utilizada pelo jogador, criei pontos falsos, que sejam próximos aos pontos REAIS.</li>
</ul>
<p>Inicialmente, esses pontos formam um quadrado em volta do ponto real. Porém, futuramente iremos arredondar a área coberta por esses pontos.</p>
<p>Parâmetros que usei para criar o mapa de calor:</p>
<ul>
<li><p><strong>qualidade</strong> - Esse parâmetro define o tamanho da célula que iremos colorir no mapa. Ou seja, quanto <strong>menor</strong> a célula, <strong>maior a qualidade</strong> do gráfico.</p></li>
<li><p><strong>dist_grupamento</strong> - Criei essa medida para separar grupamento de pontos. Se os pontos tiverem uma distância maior que o parâmetro, entende-se que são blocos de pontos separados.</p></li>
<li><p><strong>corte_distancia</strong> - Esse é o parâmetro para arredondar as áreas criadas. Os pontos falsos que possuírem uma distância maior que o percentil definido pelo <em>corte_distancia</em> serão excluídos.</p></li>
</ul>
<pre class="r"><code>#definindo os parâmetros
qualidade&lt;-0.002 #quanto menor, melhor será a qualidade e mais demorada será a execução do código
dist_grupamento&lt;-0.1
corte_distancia&lt;-0.75</code></pre>
<p>Ler no R a imagem do campo de futebol.</p>
<pre class="r"><code>library(png)
library(grid)
r &lt;- readPNG(&#39;images/post_interno/campo.png&#39;) #Ler a imagem de fundo que vamos usar para o campo de futebol
rg &lt;- rasterGrob(r, width=unit(0.9,&quot;npc&quot;), height=unit(0.9,&quot;npc&quot;)) #Ajustes para usar a imagem como fundo do mapa de calor</code></pre>
<p><a href="https://luisotavio.pro/images/post_interno/campo.png" target="_blank">Imagem disponível nesse link</a></p>
<p>Ler as informações do jogador Victor Ferraz. As informações são as coordenadas X e Y das jogadas do atleta.</p>
<pre class="r"><code>library(readr)
coordenadas &lt;- read_delim(&quot;dados_victorferraz.txt&quot;, 
    &quot;\t&quot;, escape_double = FALSE, trim_ws = TRUE)</code></pre>
<pre><code>## Parsed with column specification:
## cols(
##   x = col_double(),
##   y = col_double()
## )</code></pre>
<pre class="r"><code>head(coordenadas)</code></pre>
<pre><code>## # A tibble: 6 x 2
##       x     y
##   &lt;dbl&gt; &lt;dbl&gt;
## 1  0.75  0.37
## 2  0.9   0.56
## 3  0.86  0.47
## 4  0.93  0.33
## 5  0.74  0.52
## 6  0.84  0.64</code></pre>
<p><a href="https://luisotavio.pro/blog/dados_victorferraz.txt" target="_blank">Dados disponíveis nesse link</a></p>
</div>
<div id="criando-pontos-falsos" class="section level4">
<h4>Criando pontos falsos</h4>
<p>Agora, precisamos <strong>criar os pontos falsos</strong>.</p>
<p>Para criar os pontos falsos, vou mostrar duas formas de fazer isso e elas serão muito importantes <strong>PARA QUALQUER CASO</strong> que você esteja usando o R.</p>
<ul>
<li><p>A primeira maneira é muito fácil e <strong>MUITO INTUITIVA</strong>, porém <strong>MUITO DEMORADA</strong> para executar tudo.</p></li>
<li><p>A segunda maneira é a ideal. O código será executado praticamente instantaneamente.</p></li>
</ul>
<p><strong>Os dois códigos vão fazer exatamente a mesma tarefa: criar pontos falsos próximos de pontos reais.</strong></p>
<p>As duas versões irão criar pontos próximos as coordenadas dos pontos reais. A quantidade de pontos nessa área será definida pelo parâmetro de <strong>qualidade</strong>. Os novos pontos terão as coordenadas com diferenças entre -0.05 e 0.05 dos pontos reais para os eixos X e Y.</p>
<p><strong>VERSÃO 1</strong></p>
<pre class="r"><code>########## criar pontos falsos ###########################
coordenadas_fake&lt;-data.frame()   # cria a tabela de coordenadas falsas
for(ponto in 1:nrow(coordenadas)){ #cria um looping para cada ponto real
  for(valor_y in seq(-0.05,0.05,qualidade)){ #cria um looping para ir alterando o valor de Y de cada coordenada
    for(valor_x in seq(-0.05,0.05,qualidade)){ #cria um looping para ir alterando o valor de X de cada coordenada
      coordenadas_fake&lt;-rbind(coordenadas_fake, #cria UM ponto falso e adiciona na tabela
                              data.frame(x=coordenadas[ponto,&quot;x&quot;]+valor_x,y=coordenadas[ponto,&quot;y&quot;]+valor_y))
    }
  }
}</code></pre>
<p>Essa é a versão intuitiva. Ela cria 3 FOR <em>loopings</em>, o que é bem custoso para o computador executar.</p>
<p><strong>VERSÃO 2</strong></p>
<p>Inicialmente iremos criar dois vetores para definir as variações das coordenadas X e Y. Até então, nenhuma novidade. Isso também foi feito quando definimos o <em>looping</em> FOR na versão 1.</p>
<pre class="r"><code>valor_y&lt;-seq(-0.05,0.05,qualidade)
valor_x&lt;-seq(-0.05,0.05,qualidade)</code></pre>
<p>No segundo passo, iremos definir a função que cria um ponto falso. Também não é uma novidade em relação a 1ª versão.</p>
<pre class="r"><code>criar_coordenadas&lt;- function(valor_x,valor_y){
  c(coordenadas[,&quot;x&quot;]+valor_x,coordenadas[,&quot;y&quot;]+valor_y)
}</code></pre>
<p>Agora sim, a diferença!</p>
<p>Para substituir as funções <code>for</code>, o R possui funções da família <code>apply</code>, que são as funções <code>lapply</code>, <code>sapply</code>, <code>apply</code>, entre outras.</p>
<p>A função escolhida depende principalmente do formato dos dados. Podemos usar a função <code>lapply</code> para criar listas, o que é exatamente o nosso caso.</p>
<p>As funções dessa família irão percorrer todo o vetor ou todas as linhas ou colunas de sua tabela de uma vez só. Quando utilizamos o <em>script</em> da versão 1, o código executa um elemento da tabela por vez.</p>
<p>Como desejamos que as coordenadas sejam criadas com todas as combinações dos vetores <em>valor_x</em> e <em>valor_y</em>, iremos usar duas funções <code>lapply</code>, uma dentro da outra.</p>
<pre class="r"><code>library(data.table)
criando_coordenadas &lt;-lapply(valor_x, function(valor_x) lapply(valor_y, function(valor_y) criar_coordenadas(valor_x,valor_y))) #Cria lista com as coordenadas
coordenadas_fake&lt;-rbindlist(unlist(criando_coordenadas, recursive = FALSE)) #transforma a lista em data frame</code></pre>
<p>Pronto. Essa é a versão 2. Sempre que possível, substitua os seus <em>looping</em> FOR pelas funções da família apply. Com isso você irá melhorar muito a performance do código.</p>
</div>
<div id="eliminar-pontos-falsos-que-não-sejam-tão-próximos-dos-reais." class="section level4">
<h4>Eliminar pontos falsos que não sejam tão próximos dos reais.</h4>
<p>Esse passo é muito útil para deixar as áreas do mapa de calor com a aparência menos quadrada.</p>
<p>Adotei a estratégia de medir as distâncias entre pontos que tenham uma proximidade de até 0.1, isso é definido pelo parâmetro <code>dist_grupamento</code>.</p>
<p>Caso a distâcia seja maior que o parâmetro estabelecido, eu vou entender que os pontos estão em áreas distantes e que não há relação entre elas. Ou seja, não nos ajudaria para deixar uma área com formato menos quadrado.</p>
<p>Distância entre as coordenadas reais e as coordenadas falsas:</p>
<pre class="r"><code>library(proxy)
distancias&lt;-dist(coordenadas_fake,coordenadas,method = &quot;euclidean&quot;)</code></pre>
<p>Para cada ponto falso, vamos medir qual é o ponto real mais próximo. Criando um ranking do mais próximo até o mais distante.</p>
<pre class="r"><code>library(dplyr)
distancias_rank&lt;-sapply(1:nrow(distancias), function(x){min_rank(distancias[x,])}) %&gt;%
  t()</code></pre>
<p>Escolher quais os pontos falsos estão próximos de pelo 1 ou 2 pontos reais e, ao mesmo tempo, dentro do raio definido pela <code>dist_grupamento</code>.</p>
<pre class="r"><code>matriz_logica&lt;-(distancias_rank&lt;=2) &amp; (distancias&lt;dist_grupamento) #pra ser verdadeiro tem que ser uma das 
                                    #duas distâncias mais próximas e menor que dist_grupamento</code></pre>
<p>Para os pontos considerados acima, vamos medir a distância média entre o ponto falso e os pontos verdadeiros:</p>
<pre class="r"><code>distancias_media&lt;-sapply(1:nrow(distancias),function(x) mean(distancias[x,matriz_logica[x,]],na.rm = T))</code></pre>
<p>Finalmente, já podemos arredondar as áreas do jogador. Então vamos escolher o critério de corte para os pontos mais distantes.</p>
<p>Esse corte é definido pelo parâmetro <code>corte_distancia</code>. O seu valor é 0.75, então significa que ordenando o valor de distância de todos os pontos falsos, vamos pegar os 75% que têm os menores valores de distância.</p>
<pre class="r"><code>percentil&lt;-quantile(distancias_media, corte_distancia,na.rm = T) 
coordenadas_fake&lt;-coordenadas_fake[distancias_media&lt;percentil,]
coordenadas_fake&lt;-anti_join(coordenadas_fake,coordenadas) #evitar que pontos falsos repitam pontos reais
coordenadas_fake&lt;-unique(coordenadas_fake) #remover pontos duplicados</code></pre>
<p>Agora, vamos adicionar os vértices do campo, apenas para definir limites de espaço e juntar os todos os pontos (falsos e reais)</p>
<pre class="r"><code>vertices&lt;-data.frame(x=c(0,0,1,1),y=c(0,1,0,1))
dados_estrutura&lt;-rbind(coordenadas,coordenadas_fake,vertices)
dados_estrutura$id&lt;-1:nrow(dados_estrutura)</code></pre>
</div>
<div id="criando-polígonos" class="section level4">
<h4>Criando polígonos</h4>
<p>Cada jogada do jogador é definida em uma coordenada exata. Porém, para colorir o mapa, é necessário que esse ponto seja representado por um polígono.</p>
<p>Para cada ponto do objeto <code>dados_estrutura</code> criado, vamos fazer um quadrado para que ele possa ser colorido.</p>
<pre class="r"><code>library(sf)
lista &lt;- lapply(1:nrow(dados_estrutura), function(x){
  ## create a matrix of coordinates that also &#39;close&#39; the polygon
  res &lt;- matrix(as.numeric(c(dados_estrutura[x, &#39;x&#39;], dados_estrutura[x, &#39;y&#39;],
                  dados_estrutura[x, &#39;x&#39;], dados_estrutura[x, &#39;y&#39;]-qualidade/2,
                  dados_estrutura[x, &#39;x&#39;]-qualidade/2, dados_estrutura[x, &#39;y&#39;]-qualidade/2,
                  dados_estrutura[x, &#39;x&#39;]-qualidade/2, dados_estrutura[x, &#39;y&#39;],
                  dados_estrutura[x, &#39;x&#39;], dados_estrutura[x, &#39;y&#39;]))  ## need to close the polygon
                , ncol =2, byrow = T
  )
  ## create polygon objects
  st_polygon(list(res))
})
sfdf &lt;- st_sf(id = dados_estrutura[, &#39;id&#39;], st_sfc(lista)) #transformando para o formato adequado</code></pre>
<p>Agora, vamos criar a estrutura do mapa onde precisamos colorir:</p>
<pre class="r"><code>estrutura_mapa &lt;-st_make_grid(sfdf,cellsize = c(qualidade,qualidade)) %&gt;%
  st_as_sf() 
plot(estrutura_mapa)</code></pre>
</div>
<div id="intensidade-de-cada-área" class="section level4">
<h4>Intensidade de cada área</h4>
<p>Caso o atleta tenho feito uma jogada no ponto A e uma jogada no ponto B, a princípio elas devem ter a mesma coloração. Certo?</p>
<p>Caso o atleta tenha feito várias jogadas em volta de um ponto C, devemos destacar isso em nosso mapa.</p>
<p>Então, agora é a hora de definir um valor para cada ponto do mapa. Todos os pontos (falsos ou reais) terão um valor que corresponderá a intensidade daquele ponto.</p>
<p>Para definir a intensidade dos pontos reais, usei uma regra bem simples: quantos pontos reais estão próximos?</p>
<p>Entenda-se por próximo os pontos que estão no mesmo conjunto, ou seja, possuem distâncias menores que o parâmetro <code>dist_grupamento</code>.</p>
<pre class="r"><code>distancias_reais&lt;-proxy::dist(coordenadas,coordenadas,method = &quot;euclidean&quot;) #distância entre os pontos reais
distancias_reais&lt;-distancias_reais&lt;dist_grupamento    #variável lógica
coordenadas$intensidade&lt;-apply(distancias_reais, 1, FUN=sum) #soma a quantidade de TRUE para o comando anterior. Ou
                                                              #seja, a quantidade de pontos no mesmo conjunto. 
coordenadas.sf &lt;- st_as_sf(coordenadas,coords = c(&#39;x&#39;,&#39;y&#39;)) # ajustar para o formato adequado</code></pre>
<p>Criar um modelo para prever a intensidade dos pontos falsos</p>
<pre class="r"><code>library(gstat)
modelo&lt;-gstat(formula = intensidade~1,
              data = as(coordenadas.sf,&#39;Spatial&#39;),
              set=list(idp=1))</code></pre>
<p>Prever as intensidades para os pontos falsos</p>
<pre class="r"><code>dados.mapa &lt;- predict(modelo,as(estrutura_mapa,&#39;Spatial&#39;)) %&gt;%
  st_as_sf()</code></pre>
</div>
<div id="o-nosso-mapa-de-calor-ufa" class="section level4">
<h4>O NOSSO MAPA DE CALOR! UFA…</h4>
<p>Vamos usar a biblioteca <code>ggplot2</code> para finalmente gerar o nosso mapa de calor.</p>
<p>Esse último passo busca os dados calculados até agora (<code>dados.mapa</code>) e junta com a imagem do campinho.</p>
<p>Além disso, são definidas as escalas de cores e os limites mínimo e máximo para a intensidade.</p>
<pre class="r"><code>library(ggplot2)
library(fields) #biblioteca para usar a paleta de cores tim.colors

ggplot(dados.mapa) +  #dados calculados até aqui para o mapa de calor.
  annotation_custom(rg) + # Essa linha adiciona o campinho no atrás do mapa de calor.
  geom_sf(aes(fill=var1.pred,col=var1.pred), show.legend = FALSE)+
  scale_color_gradientn(colors = c(tim.colors(50,alpha =1)), ## cor da borda dos polígonos
                        limits=c(min(dados.mapa$var1.pred),max((dados.mapa$var1.pred))))+
  scale_fill_gradientn(colors =  c(tim.colors(50,alpha =1)), ## cor dentro dos polígonos
                       limits=c(min(dados.mapa$var1.pred),max((dados.mapa$var1.pred))))+
  theme_void()       </code></pre>
<div class="figure">
<img src="/images/post_interno/mapacalor_lat_direito.png" alt="Mapa de Calor - Futebol" style="width:75.0%" />
<p class="caption">Mapa de Calor - Futebol</p>
</div>
</div>
</div>
