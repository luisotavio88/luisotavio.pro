[
["index.html", "O primeiro passo como Cientista de Dados Bem-vindos", " O primeiro passo como Cientista de Dados Luís Otávio Bem-vindos "],
["intro.html", " 1 Introdução", " 1 Introdução You can label chapter and section titles using {#label} after them, e.g., we can reference Chapter 1. If you do not manually label them, there will be automatic labels anyway, e.g., Chapter ??. Figures and tables with captions will be placed in figure and table environments, respectively. par(mar = c(4, 4, .1, .1)) plot(pressure, type = &#39;b&#39;, pch = 19) Figure 1.1: Here is a nice figure! Reference a figure by its code chunk label with the fig: prefix, e.g., see Figure 1.1. Similarly, you can reference tables generated from knitr::kable(), e.g., see Table 1.1. knitr::kable( head(iris, 20), caption = &#39;Here is a nice table!&#39;, booktabs = TRUE ) Table 1.1: Here is a nice table! Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5.0 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa 5.4 3.7 1.5 0.2 setosa 4.8 3.4 1.6 0.2 setosa 4.8 3.0 1.4 0.1 setosa 4.3 3.0 1.1 0.1 setosa 5.8 4.0 1.2 0.2 setosa 5.7 4.4 1.5 0.4 setosa 5.4 3.9 1.3 0.4 setosa 5.1 3.5 1.4 0.3 setosa 5.7 3.8 1.7 0.3 setosa 5.1 3.8 1.5 0.3 setosa www.luisotavio.pro "],
["oquefaz.html", " 2 O que faz um cientista de dados?", " 2 O que faz um cientista de dados? e porque me tornar um? Here is a review of existing methods. www.luisotavio.pro "],
["iniciando-com-o-r.html", " 3 Iniciando com o R 3.1 Instalação 3.2 Lógica de programação no R 3.3 Objetos 3.4 Vetores 3.5 Matrizes 3.6 Listas 3.7 Fatores 3.8 Coerção de classes 3.9 Valores faltantes 3.10 Data Frames 3.11 Names", " 3 Iniciando com o R 3.1 Instalação Todos os passos que sugiro nesse e-book são 100% gratuitos. Você irá instalar o R, o RStudio e várias bibliotecas que vão facilitar a nossa vida, porém não há nenhum custo financeiro nisso! Então, primeiramente, você precisa ter o software R instalado no seu computador. E, logo depois, instalar o RStudio. O RStudio é uma interface para facilitar a sua vida. Ele irá deixar a sua tela de programação muito mais amigável, organizada e você terá várias funções que irão facilitar o desenvolvimento do seu projeto. Usar o R sem o RStudio é inimaginável hoje em dia. Não tem nenhum motivo pra você fazer isso, então instale também o RStudio. Caso você precise de ajuda para instalar o R e o RStudio, veja o passo a passo: Clique aqui para ver o passo a passo de instalação do R e do RStudio. 3.2 Lógica de programação no R A linguagem R é orientada a objetos e, na prática,isso significa que tudo no R será um objeto. Imagine que esse “objeto” é uma variável capaz de armazenar um valor ou uma estrutura de dados. Por exemplo: variavel1&lt;- 5 dataset1 &lt;- cars Na primeira linha do código eu estou atribuindo o valor 5 para o objeto “variavel1”, criado por mim. O operador de atribuição é representado pelo “&lt;-”. Você vai escolher o nome que mais fizer mais sentido para o seu objeto, de forma que fique fácil de saber do que se trata. Seguindo o mesmo raciocínio, eu paguei um conjunto de dados do R, que se chama “cars” e atribui esse conjunto para o objeto “cars”. Então, agora o “dataset1” recebeu a estrutura de dados que estava no dataset “cars” e os dois objetos terão o mesmo valor. As funções no R No R existem várias funções já pré-definidas. Elas servem para facilitar trabalhos que são feitos por muitas pessoas. Imagine que existe um trabalho repetitivo que várias pessoas precisem fazer. Agora imagine que alguém já escreveu todo o passo a passo desse trabalho repetitivo e você só precisará usar a função que essa pessoa escreveu. Por exemplo, calcular a média aritmética é um trabalho que muitos usuários do R vão usar, então já existe uma função para isso. Essa função é A mean(). Para usar uma função, você vai inserir dentro da função os argumentos necessários. Para calcular a média, o único argumento necessário são os números dos quais você quer saber a média. numeros &lt;- 10:15 # estou atribuindo os números 10, 11, 12, 13, 14 e 15 para o objeto &quot;numeros&quot; numeros # pedi para o R imprimir no Console o objeto &quot;numeros&quot; ## [1] 10 11 12 13 14 15 mean(numeros) # pedi para o R imprimir a média do objeto &quot;numeros&quot; ## [1] 12.5 obs.: Sempre que você usar uma # (hashtag) em seu código, o R irá ignorar o que está à direita da Hashtag. Isso é muito útil para que você faça comentários no seu código. Isso vai facilitar muito quando você for ler o código depois de alguns dias que escreveu. E também será extremamente útil se outra pessoa precisar ler o seu código. O R possui milhares e milhares de funções já prontas que irão nos ajudar muito no desenvolvimento de nossos projetos. Para você saber qual a função que irá fazer o que você está precisando, sugiro que procure no Google. Por exemplo: Caso você queira calcular a mediana dos seus dados, coloque no Google: R como calcular a mediana. E com dois cliques você irá descobrir que deve usar a função median() 3.3 Objetos Cada objeto irá ter uma Classe. Ela é definida pela forma do objeto e será muito importante na maneira que o objeto será manipulado pelas funções. Existem 5 classes básicas (atômicas) para um objeto no R: Caractere (character) Números reais (numeric) Inteiros (integer) Números complexos (complex) Verdadeiro/Falso (logical) Para descobrir qual é a Classe do objeto, podemos usar a função class(). class(&quot;Essa é uma frase.&quot;) ## [1] &quot;character&quot; class(5.6761) ## [1] &quot;numeric&quot; class(TRUE) ## [1] &quot;logical&quot; Sempre que usarmos texto, ele deve estar entre aspas. Assim o R irá entender que é um texto e não um objeto. Por exemplo: texto &lt;- &quot;palavra&quot; #aqui estou atribuindo &quot;palavra&quot; para o objeto texto. # Então quando eu escrever texto sem aspas, o R saberá que # não é um texto e sim um objeto. Veja: texto ## [1] &quot;palavra&quot; # o R irá acusar erro, porque não existe um objeto chamado palavra. palavra ## Error in eval(expr, envir, enclos): objeto &#39;palavra&#39; não encontrado 3.4 Vetores Vetor é um conjunto de valores da mesma classe. Por exemplo: inteiros &lt;- c(1,3,5,6) #A função &quot;c&quot; irá organizar os valores em vetor. # Os elementos do vetor são separados por vírgula. # veja que todos os valores tem a mesma classe - a classe # de números inteiros. logicos &lt;- c(TRUE,FALSE,TRUE) #Vetor com valores lógicos verdadeiro/falso logicos &lt;- c(T,F,T) #Você pode escrever TRUE ou somente T, FALSE # ou somente F e o R irá entender # que se trata de valores lógicos 3.5 Matrizes Imagine alguns vetores do mesmo tamanho: vetor1 &lt;- c(0,1,2,3) vetor2 &lt;- c(3,2,1,0) vetor3 &lt;- c(1,1,1,1) Uma matriz é um conjunto de vetores do mesmo tamanho. Ou uma tabela com linhas e colunas. Como você preferir! matrix(cbind(vetor1,vetor2,vetor3),ncol=3) #a função matrix é usada para criar uma matriz ## [,1] [,2] [,3] ## [1,] 0 3 1 ## [2,] 1 2 1 ## [3,] 2 1 1 ## [4,] 3 0 1 #o primeiro argumento da padrão matrix são os dados da matriz #além disso o argumento &quot;ncol&quot; irá informar que desejamos formar 3 colunas. #Assim, cada vetor definido anteriormente será uma coluna da matriz Outro exemplo: matrix(1:6, nrow = 2, ncol = 3) #Foram definidos os valores de 1 a 6 no argumento de dados da função. ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 #e também foi definido que número de linhas (nrow) igual a 2 #e o número de colunas igual a 3. Importante: todas as colunas de uma matriz possuem a mesma classe. Ou seja, são todas numéricas, lógicas, caracteres, etc. 3.6 Listas Você vai usar bastante as listas em seus trabalhos. A principal característica delas é aceitar elementos de diferentes classes. Além disso, podem armazenar vetores e matrizes em um único objeto. Exemplo: vetor1 &lt;- c(TRUE,FALSE,TRUE) #Vetor com valores lógicos vetor2 &lt;- c(2,3,4,5,6,7,8,9) #Vetor com valores inteiros valor_texto &lt;- &quot;Esse é um texto.&quot; #Elemento da classe character lista &lt;- list(vetor1,vetor2,valor_texto) lista ## [[1]] ## [1] TRUE FALSE TRUE ## ## [[2]] ## [1] 2 3 4 5 6 7 8 9 ## ## [[3]] ## [1] &quot;Esse é um texto.&quot; 3.7 Fatores Até agora usamos em nossos exemplos valores lógicos (TRUE/FALSE), valores númericos ou de texto (character). Porém, é essencial conhecer outra classe de valores: os fatores. Fator é a classe das variáveis categóricas. Uma variável categórica pode ser ordenada, como a renda: salários até R$ 5.000, entre R$ 5.001 e 10.000 e acima de R$ 10.000. Ou podemos ter categorias que não possuem nenhuma ordem, como cursos: Administração, Economia, Ciência Contábeis. Nos dois exemplos, as variáveis renda e cursos poderiam assumir a classe “factor” em nossas análises. Também seria possível classificar renda e cursos (ou qualquer variável categórica) como uma variável de texto (character). Então pra que serve a classe dos fatores? Sempre que você tiver poucos valores únicos para uma variável, prefira a classicação de fator à character. Essa opção irá otimizar o armazenamento dos dados e também será necessária para utilizar algumas funções do R com seus dados. Exemplo: Uma pergunta aberta em um questionário irá gerar várias respostas diferentes, então não há sentido nenhum em classificar as respostas em categorias. Portanto, a classificação adequada é character. Porém, caso o respondente tenha que escolher uma resposta entre algumas opções disponíveis para esse questionário, a melhor classificação da variável seria como fator. O R sempre irá assumir uma classificação para a sua variável e, a priori, você não precisará fazer essa classificação. Ela só é necessária quando a classificação automática feita pelo R for indevida para o seu caso. 3.8 Coerção de classes Em alguns casos, você pode precisar alterar a classe de objetos. Suponha, por exemplo, que você criou o seguinte vetor x. x&lt;-c(0,1,0,1,1) O R irá automaticamente entender que o vetor x é numeric class(x) ## [1] &quot;numeric&quot; Porém, pode ser que você precise desse vetor como integer (números inteiros) ou logical (verdadeiro/falso). Por definição 0 seria FALSO e 1 seria VERDADEIRO. Para alterar a classe de um objeto por coerção, basta você usar uma função de coerção. As função são definidas por as. + classe que o objeto vai assumir. Ou seja: as.integer, as.logical, as.numeric, as.factor as.complex ou as.character. Para o exemplo acima, teríamos: as.integer(x) ## [1] 0 1 0 1 1 as.logical(x) ## [1] FALSE TRUE FALSE TRUE TRUE Dica importante: Muito cuidado ao converter objetos classificados como FATORES para NUMÉRICOS. Para fazer isso sem perder informação, você precisa converter primeiramente para character e, posteriormente, para numeric. 3.9 Valores faltantes Os valores faltantes, também chamados de missing values são representados por NA ou NaN. Eles não irão influenciar a classe de um objeto, por exemplo: x&lt;-c(1,2,NA,1,0) #apesar de ser representado por duas letras, pelo padrão do R, ele saberá que não se trata de um texto e sim de valores faltantes. class(x) ## [1] &quot;numeric&quot; 3.10 Data Frames Provavelmente esse é o objeto mais usado no R. É similar a uma matriz, porém com mais possibilidades. Os Data Frames são tabelas que aceitam colunas de todas as classes. Por exemplo, podemos ter uma coluna com classe numeric, outra logical e outra character. Isso não é possível em uma matriz, onde todas as colunas devem ter a mesma classe. Cada coluna em um Data Frame terá um nome. É altamente recomendável que você atribua nomes que realmente representem a variável ali contida. Ou seja, evite nomes como X1, X2, X3, etc. Também é possível atribuir nomes para as linhas de seu data frame. É muito comum que você importe seus dados/tabela para o R, porém veja como você pode criar um data frame de forma bem simples: meus_dados &lt;- data.frame(produto=c(&quot;roda&quot;,&quot;pneu&quot;,&quot;suspensão&quot;), preco = c(30,20,15), esta_disponivel = c(T, T, F)) meus_dados ## produto preco esta_disponivel ## 1 roda 30 TRUE ## 2 pneu 20 TRUE ## 3 suspensão 15 FALSE O data frame criado acima possui variáveis de texto, numérica e lógica. 3.11 Names Os names são muito úteis na manipulação dos dados contidos nas matrizes, listas ou data frames. Por exemplo, no data frame meus_dados criado no item anterior, foi definido que o nome das variáveis são: produto, preco e esta_disponivel. Isso pode ser identificado pela função names() names(meus_dados) ## [1] &quot;produto&quot; &quot;preco&quot; &quot;esta_disponivel&quot; Então, para manipular a primeira coluna, podemos chamá-la de “roda” no comando que for utilizado. Isso será melhor explicado no capítulo de manipulação de dados. Para alterar os nomes das colunas ou linhas de um data frame, usa-se as funções names() e row.names(). names(meus_dados)&lt;-c(&quot;novo_nome&quot;,&quot;preco&quot;,&quot;esta_disponivel&quot;) #alterando o nome da 1a coluna meus_dados ## novo_nome preco esta_disponivel ## 1 roda 30 TRUE ## 2 pneu 20 TRUE ## 3 suspensão 15 FALSE www.luisotavio.pro "],
["instalar-pacotes-no-r.html", " 4 Instalar Pacotes no R 4.1 Como instalar um pacote no R ou RStudio", " 4 Instalar Pacotes no R O R é uma linguagem inicialmente dedicada a métodos estatísticos. Como a Estatística é uma ciência extremamente ampla, são os pacotes que permitem o R ser um software tão completo! Olha só: O R é utilizado por pessoas da área de economia, previsões do tempo, área de saúde, demografia, machine learning, deep learning e várias outras… Sendo que cada uma das áreas citadas ainda tem vários subnichos. Então o que acontece é o seguinte: existem milhares de pessoas ao redor do mundo que são muito boas em suas áreas e criam pacotes dentro do R para atender demandas específicas. Que, geralmente, ainda não tinham sido solucionadas de forma eficaz. Isso só é possível porque o R é um software Open Source. Isso significa que as pessoas podem contribuir para melhorar as funcionalidades do programa! Com certeza, isso é determinante para o R ser tão completo. O que estou falando é que se um especialista da sua área de uma universidade renomada publica um pacote no R, ele estará disponível para você usar no seu computador! Gratuitamente. Agora que você já entendeu o contexto, vamos definir o que é um pacote do R: Um Pacote é um conjunto de funções dentro do R, geralmente relacionados a um tema específico. Além disso, os pacotes também têm uma documentação. Essa documentação explica para o que serve cada função do pacote. Te explica como usar cada função e ainda fornece exemplos práticos de uso. 4.1 Como instalar um pacote no R ou RStudio Quando fazemos o download do R, também já estamos baixando os pacotes considerados básicos. Mas muitas vezes você vai precisar de um pacote específico, pode ser para fazer um gráfico mais bonito, para trabalhar com datas de uma forma mais eficiente ou para trabalhar com mais qualidade com o próprio tema do seu projeto. E para isso vamos fazer o download desse pacote, é muito simples! O ggplot2 é um pacote muito usado para fazer gráficos mais elaborados, com grande capacidade de personalização. Vamos usá-lo aqui como exemplo. Existem três maneiras comuns para se instalar um pacote. As duas primeiras são as maneiras mais tradicionais. Já a terceira será utilizada quando o pacote não estiver disponível para download na rede do R. 4.1.1 Usando o botão de instalação Essa forma é muito intuitiva, clique na aba “Packages” (veja na imagem) e depois em “Install”. Irá abrir uma tela para você escolher o pacote que deseja instalar. botao instalacao pacote Escreva o nome o pacote e clique em “Install”. Simples assim! Mas ainda falta um detalhe. Agora o pacote já está instalado no R, em sua biblioteca. Mas falta um detalhe, precisamos ir lá na biblioteca e buscar esse pacote! Para carregar o pacote instalado, basta executar o seguinte código: library(ggplot2) #Esse exemplo irá carregar o pacote ggplot2, #então coloque o nome do pacote que você instalou e deseja carregar. 4.1.2 Usando o comando de instalação O primeiro passo é escrever o comando install.packages(\"ggplot2\") e executar o código! botao install Execute o código: install.packages(&quot;ggplot2&quot;) #Esse exemplo irá instalar o pacote ggplot2, # então coloque o nome do pacote que você deseja instalar. Depois que o código for executado, o pacote será instalado. Isso quer dizer que o pacote está instalado no R, em sua biblioteca. Mas também precisamos ir lá na biblioteca e buscar esse pacote. library(&quot;ggplot2&quot;) #Esse exemplo irá carregar o pacote ggplot2, # então coloque o nome do pacote que você instalou e deseja carregar. 4.1.3 Usando o Devtools A rede onde estão armazenados os pacotes do R é conhecida como CRAN. Em alguns casos, o pacote que você deseja instalar não estará disponível no CRAN. Há uma maneira muito simples de resolver isso. Vários desenvolvedores de pacotes os armazenam no Github. Imagine que você esteja procurando no Google como solucionar um problema e encontre um pacote que resolverá sua questão, mas não está disponível no CRAN. Provavelmente o pacote está disponível no Github e poderá ser instalado usando o pacote Devtools. O primeiro passo é instalar o Devtools (que está disponível para ser instalada normalmente pela rede do R). install.packages(&quot;devtools&quot;) O script a seguir deve ser adaptado ao pacote que você quiser instalar. Você o encontrará na página do Github do pacote que irá instalar. Provavelmente na seção Readme. Para exemplificar, vou instalar o pacote rCharts, que não está disponível para instalação usando os primeiros métodos falados aqui. library(devtools) install_github(&#39;ramnathv/rCharts&#39;) # ramnathv é o usuário do Github que criou o pacote rCharts Pronto. O comando acima irá instalar o pacote rCharts que não pode ser instalado pelas duas primeiras formas mostradas. Seguindo o mesmo raciocínio anterior, você precisará chamar o pacote antes de utilizá-lo: library(rCharts) www.luisotavio.pro "],
["como-ler-ou-salvar-seus-dados.html", " 5 Como ler ou salvar seus dados 5.1 Como importar uma tabela em arquivo txt ou csv para o RStudio 5.2 Como importar dados do Excel para o RStudio", " 5 Como ler ou salvar seus dados Nesse capítulo vou te apresentar as principais formas de importar os seus dados para o R. Em alguns casos específicos, a importação dos dados pode depender de pacotes desenvolvidos especialmente para o caso. Aqui vou abotar a importação de arquivos de texto, CSV ou Excel. Vou tratar sobre a importação de dados do Excel no final deste capítulo. Porém, caso você queira importar poucas abas de uma planilha do Excel, recomendo que você a salve como arquivo TXT e faça a importação usando o método a seguir. 5.1 Como importar uma tabela em arquivo txt ou csv para o RStudio 5.1.1 Método sem nenhuma linha de código Após aplicar esse método, você terá importado seus dados em segundos e, além disso, o R te mostrará qual o código ele executou para abrir a sua tabela! Ou seja, uma ótima oportunidade pra você entender melhor sobre a linguagem. Passo 1 - Na parte “Enviroment” clique em Import Dataset -&gt; From Txt (readr) Lembre-se que os seus dados devem estar salvos no formato txt ou csv. Importar dados no R-RStudio Para ler os dados vamos usar a biblioteca “readr”, então, caso você ainda não tenha ela instalada em seu computador, o RStudio irá solicitar a sua instalação. Passo 2 - Instale a biblioteca “readr”, caso ela já não esteja instalada Importar dados no R-RStudio Clique em “Yes” e aguarde a instalação. Passo 3 - Ajustes para importar a sua tabela Importar dados no R-RStudio Primeiramente, clique em “Browse” e selecione o arquivo que você deseje importar. Uma pequena parte dos dados do arquivo que você selecionou irão aparecer na sua tela, para te auxiliar na importação. Então, agora você precisa fazer alguns ajustes para o R ler o seu dataset. O ajuste mais importante é como as suas colunas estão separadas/delimitadas. É muito comum usar tabulação (tab), vírgula, ponto e vírgula ou espaço para separar as colunas de arquivos de texto. Mas nessa parte da importação, você deve escolher exatamente o mesmo delimitador que já foi utilizado em seu arquivo. Nessa seção, você também pode fazer vários outros ajustes, por exemplo: escolher o nome da tabela que será importada definir qual se os números decimais da sua tabela estão separados por ponto ou vírgula. No R o separador decimal é por ponto, então caso o seu arquivo use vírgula, o R saberá que deve transformar pra ficar dentro do padrão. alterar qual a codificação dos seus dados (ASCII, utf8, etc…) definir se a primeira linha dos seus dados é cabeçalho ou não Note que nessa etapa, na parte de “Code Preview”, o RStudio está mostrando exatamente o código que será executado para fazer a leitura dos seus dados. Esse código vai alterando a medida que você muda os ajustes! (ótima oportunidade para aprender e ir entendendo melhor o funcionamento da linguagem). Após realizar os ajustes necessários (que vão depender da sua própria tabela), clique em Import Pronto, agora os seus dados foram importados. Você pode conferir que a sua tabela irá aparecer em “Enviroment”. É só clicar nela para visualizar os dados. 5.1.2 Importando dados com a função read.table A função mais comum para importar dados no R é a read.table. A função é bem simples, vou mostrar a seguir: meus_dados&lt;-read.table(file=&quot;nome_do_arquivo.txt&quot;,header = TRUE,sep = &quot;\\t&quot;) Portanto, esse comando irá ler o arquivo “nome_do_arquivo.txt”. Além disso, foi informado que o arquivo possui cabeçalho (nome para cada coluna da tabela) e está separado por tabulação, representado pelo símbolo \". Você pode atribuir valores para outros argumentos, como: dec (para definir o separador de números decimais), row.names (para atribuir nomes para cada linha), encoding (definir a codificação dos seus dados) e vários outros. Essas opções só precisarão ser utilizadas em casos especiais, quando seus dados não estiverem no padrão definido pelo R. Como qualquer função no R, você terá acesso a documentação da função executanto o comando ?read.table. 5.2 Como importar dados do Excel para o RStudio A seguir temos 3 métodos para ler dados do Excel no RStudio. Todos são bem simples e cada um será mais útil em um tipo de situação. 5.2.1 Copiando os dados do Excel e importando para o R. 1 – Abra o seu arquivo de Excel, selecione os dados que deseja copiar e copie os dados (Ctrl + C). 2 – Execute o código abaixo para importar os dados copiados no Excel. meus_dados &lt;- read.table(file = &quot;clipboard&quot;, sep = &quot;\\t&quot;, header=TRUE) ## Warning in read.table(file = &quot;clipboard&quot;, sep = &quot;\\t&quot;, header = TRUE): incomplete ## final line found by readTableHeader on &#39;clipboard&#39; Quando copiamos os dados no Excel, eles ficam armazenados no clipboard do nosso computador, então o que estamos fazendo é falando para o R ler a tabela (função read.table) que estão no clipboard e atribuir essa tabela aos “meus_dados”. 3 – Pronto! 5.2.2 Importando arquivos do Excel sem usar programação Agora vamos ver como importar um arquivo do Excel para o R usando apenas o nosso mouse, é muito simples! 1 - Na aba “Enviroment”, vamos clicar em Import Dataset e escolher From Excel. Importar dados no R-RStudio 2 – Você provavelmente ainda não instalou o pacote readxl, então o RStudio vai te perguntar se deseja instalar o pacote. Confirme a instalação. Importar dados no R-RStudio 3 - Aparecerá uma aba para você fazer a leitura dos dados desejados. Clique em Browse para escolher o arquivo de Excel que você irá importar. Depois em Sheet escolha a aba de seu arquivo onde está a tabela que você quer importar. (Caso queira importar várias abas é só repetir os passos, importando uma aba de cada vez) Importar dados no R-RStudio 4 – Clique em Import. 5.2.3 Abrir os dados do Excel no R usando o pacote readxl Esse método é bem parecido com o último, porém aqui vamos usar linhas de código. 1 - Caso você ainda não tenha instalado o pacote readxl, execute o seguinte comando: install.packages(&quot;readxl&quot;) 2 - Vamos carregar o pacote que iremos usar (readxl): Execute o comando: library(&quot;readxl&quot;) ## Warning: package &#39;readxl&#39; was built under R version 3.6.3 3 – Agora vamos buscar a planilha que você precisa usando a função read_excel. Os argumentos que vamos usar na função são: o endereço e nome do seu arquivo; a aba da planilha que você quer ler. Excute o código: meus_dados &lt;- read_excel(&quot;seu_arquivo.xlsx&quot;, sheet = &quot;nome da aba&quot;) caso o seu arquivo esteja na mesma pasta do seu projeto, você não precisa colocar todo o endereço do arquivo. em sheet você pode colocar o nome da aba do Excel que você quer ler ou seu número (1, 2, 3, etc). Caso você coloque o número, não use aspas. essa função serve tanto para arquivos xls como para xlsx. www.luisotavio.pro "],
["manipulação-de-objetos.html", " 6 Manipulação de objetos 6.1 Manipulação de vetores 6.2 Manipulação de matrizes 6.3 Manipulação de Listas 6.4 Como extrair elementos ou objetos de uma lista", " 6 Manipulação de objetos No Capítulo 3 apresentei o conceito dos vetores, matrizes e listas. Eles são usados a todo momento no R. Agora vou mostrar como manipulá-los, extrair ou adicionar valores. 6.1 Manipulação de vetores Para criar um vetor, usamos o comando c(). meu_vetor &lt;- c(2,4,6,8,10) O comando acima irá atribuir ao objeto meu_vetor 5 elementos: números pares entre 2 e 10. 6.1.1 Como extrair elementos de um vetor Para extrair um elemento(s) de um vetor você precisará apenas escrever o nome do vetor e escolher qual(is) elemento(s) deseja extrair. Coloque os elementos dentro de colchetes, por exemplo: meu_vetor[2] #Extrai o SEGUNDO elemento do vetor ## [1] 4 meu_vetor[3:5] #Extrai o TERCEIRO, QUARTO e QUINTO elemento do vetor ## [1] 6 8 10 meu_vetor[c(1,5)] #Extrai o PRIMEIRO e o QUINTO elemento do vetor ## [1] 2 10 Então, para extrair elementos de um vetor, você precisa colocar dentro dos colchetes quais os elementos devem ser extraídos. Note que você pode colocar um novo vetor dentro dos colchetes, indicando quais serão os elementos. Nesse caso, estamos informando explicitamente quais elementos queremos extrair. Porém, também podemos usar uma condição lógica para fazer a extração: meu_vetor2&lt;-c(2,5,9,10,11,1,4) meu_vetor2[meu_vetor2 &gt; 7] #os elementos que atenderem a condição lógica serão extraídos. ## [1] 9 10 11 meu_vetor2 &gt; 7 #Note que a condição lógica irá retornar um vetor de TRUE ou FALSE. ## [1] FALSE FALSE TRUE TRUE TRUE FALSE FALSE #O resultado será TRUE quando o elemento do vetor for maior que 7 e FALSE no caso contrário. #Então, o comando meu_vetor2[meu_vetor2 &gt; 7] irá retornar os elementos correspondentes #quando a condição for igual a TRUE. 6.1.2 Como atribuir valores a elementos de um vetor Para atribuir um valor a um elemento de um vetor, vamos utilizar o mesmo raciocínio desenvolvido até aqui. Considere o vetor meu_vetor ## [1] 2 4 6 8 10 e suponha que você deseje atribuir o valor 1 para o quinto elemento deste vetor meu_vetor[5] &lt;- 1 meu_vetor #resultado ## [1] 2 4 6 8 1 6.2 Manipulação de matrizes Os vetores só tem uma dimensão, representam apenas uma variável. Já as matrizes são bidimensionais. Isso quer dizer que a matriz é uma tabela com linhas e colunas. # CRIANDO UMA MATRIZ minha_matriz &lt;- matrix(data = 1:15, nrow=5,ncol=3) minha_matriz ## [,1] [,2] [,3] ## [1,] 1 6 11 ## [2,] 2 7 12 ## [3,] 3 8 13 ## [4,] 4 9 14 ## [5,] 5 10 15 Na criação da matriz acima, informei que os dados da matriz são os números de 1 até 15, que a matriz possui 5 linhas e 3 colunas. Sempre que for manipular uma matriz, você precisará levar em consideração seus dois índices. O primeiro índice representa a linha e o segundo representa a coluna. 6.2.1 Como extrair elementos de uma matriz Considere a matriz que criamo no item anterior: minha_matriz ## [,1] [,2] [,3] ## [1,] 1 6 11 ## [2,] 2 7 12 ## [3,] 3 8 13 ## [4,] 4 9 14 ## [5,] 5 10 15 Agora, suponha que você deseja extrair o elemento localizado na última linha e na última coluna. Ou seja, você deseja extrair o elemento que está na linha=5, coluna=3. Para extrair esse elemento, basta chamar a minha_matriz e restringir pelos índices linha=5 e coluna=3. Na prática, basta executar o seguinte comando: minha_matriz[5,3] #O primeiro índice sempre se refere a LINHA e o segundo sempre se refere a COLUNA. ## [1] 15 E se quisermos extrair uma linha ou coluna inteira? É muito simples extrair uma linha ou uma coluna inteira. Por exemplo, para extrair uma linha basta que você informe qual é a linha e não faça nenhuma restrição nas colunas. # Extração da segunda linha da matriz minha_matriz[2,] #defini a linha que quero extrair e deixei o campo das colunas em branco. ## [1] 2 7 12 O mesmo raciocínio se aplica para extrair uma coluna: # Extração da terceira coluna da matriz minha_matriz[,3] #defini a coluna que quero extrair e deixei o campo das linhas em branco. ## [1] 11 12 13 14 15 Os exemplos acima extraíram apenas 1 linha ou 1 coluna. Porém, o mesmo funciona para várias linhas ou colunas. Por exemplo, agora vamos extrair a 1ª e a 3ª coluna. minha_matriz[,c(1,3)] #O índice das linhas está vazio, pois quero extrair todas as linhas. ## [,1] [,2] ## [1,] 1 11 ## [2,] 2 12 ## [3,] 3 13 ## [4,] 4 14 ## [5,] 5 15 #O vetor c(1,3) irá definir a extração das colunas 1 e 3. 6.2.2 Como atribuir valores a elementos de uma matriz Suponha que deseja atribuir o valor 1 para o elemento localizado na 2ª linha e 3ª coluna de uma matriz: minha_matriz[2,3] &lt;-1 minha_matriz ## [,1] [,2] [,3] ## [1,] 1 6 11 ## [2,] 2 7 1 ## [3,] 3 8 13 ## [4,] 4 9 14 ## [5,] 5 10 15 Também é possível atribuir valores para toda a linha ou toda a coluna: minha_matriz[,3] &lt;-21:25 #Irá atribuir os valores 21,22,23,24 e 25 para a terceira coluna da matriz minha_matriz ## [,1] [,2] [,3] ## [1,] 1 6 21 ## [2,] 2 7 22 ## [3,] 3 8 23 ## [4,] 4 9 24 ## [5,] 5 10 25 6.3 Manipulação de Listas Listas são objetos onde podemos armazenar elementos, vetores ou matrizes de diferentes classes. minha_lista&lt;- list(vetor_numerico= 1:10,texto=&quot;esse é um elemento de texto&quot;,matriz=minha_matriz) minha_lista ## $vetor_numerico ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## $texto ## [1] &quot;esse é um elemento de texto&quot; ## ## $matriz ## [,1] [,2] [,3] ## [1,] 1 6 21 ## [2,] 2 7 22 ## [3,] 3 8 23 ## [4,] 4 9 24 ## [5,] 5 10 25 Então, o comando acima gerou uma lista de tamanho igual a 3. O primeiro elemento da lista é um vetor numérico, o segundo é um texto e o terceiro a matriz que criamos anteriormente. 6.4 Como extrair elementos ou objetos de uma lista Note que ao criar a lista, foram atribuídos nomes para cada elemento da lista, o primeiro foi chamado de vetor_numero, o segundo de texto e o terceiro de matriz. Então, esses nomes podem ser utilizados na extração dos elementos de uma lista. Para isso, usamos o símbolo $. minha_lista$vetor_numerico ## [1] 1 2 3 4 5 6 7 8 9 10 O comando acima representa a extração do vetor_numerico que está dentro da lista minha_lista. Como o vetor_numerico é o primeiro elemento da lista, ele também pode ser extraído da seguinte forma: minha_lista[[1]] #na extração em listas, usa-se colchetes duplos. ## [1] 1 2 3 4 5 6 7 8 9 10 E como extrair elementos que estão dentro dos objetos vetor_numero, texto ou matriz? Suponha que você queira extrair o terceiro elemento dentro do vetor_numero: minha_lista[[1]][[3]] #Primeiro acessamos o *vetor_numero* usando [[1]] ## [1] 3 #e depois acessamos o *terceiro elemento* usando [[3]] Ou, de forma equivalente: minha_lista$vetor_numerico[[3]] ## [1] 3 A extração dos elementos da matriz, que está dentro da lista minha_lista, é bem similar. Suponha que precise extrair o elemento que está na terceira linha e segunda coluna da matriz: minha_lista$matriz[[3,2]] ## [1] 8 6.4.1 Como atribuir valores a elementos de uma lista Tanto para os vetores, matrizes e listas, a atribuição de valores funciona da mesma maneira que fazemos para extrair os dados. Porém, a diferença é que não vamos simplesmente pedir para o R mostrar os dados ou atribuílos a algum objeto. Fazemos exatamente o contrário: atribuímos algum valor àquele elemento do vetor, matriz ou lista. No exemplo a seguir, a matriz recebe o valor 5 para a linha 4, coluna 3. minha_lista$matriz[4,3] &lt;- 5 minha_lista$matriz ## [,1] [,2] [,3] ## [1,] 1 6 21 ## [2,] 2 7 22 ## [3,] 3 8 23 ## [4,] 4 9 5 ## [5,] 5 10 25 Também podemos adicionar um objeto completamente novo para a nossa lista: novo_vetor&lt;-c(50:60) minha_lista$novo_vetor&lt;-novo_vetor minha_lista ## $vetor_numerico ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## $texto ## [1] &quot;esse é um elemento de texto&quot; ## ## $matriz ## [,1] [,2] [,3] ## [1,] 1 6 21 ## [2,] 2 7 22 ## [3,] 3 8 23 ## [4,] 4 9 5 ## [5,] 5 10 25 ## ## $novo_vetor ## [1] 50 51 52 53 54 55 56 57 58 59 60 www.luisotavio.pro "],
["manipulação-de-dados-com-o-dplyr.html", " 7 Manipulação de dados com o dplyr 7.1 O que é um Data Frame? 7.2 Manipulação de um Data Frame 7.3 As funções do Dplyr 7.4 As propriedades das funções do pacote Dplyr 7.5 A função Summarise e a função group_by 7.6 Mutate 7.7 Select 7.8 Filter 7.9 Arrange 7.10 Rename 7.11 O operador %&gt;% (leia-se pipe)", " 7 Manipulação de dados com o dplyr 7.1 O que é um Data Frame? Provavelmente você já utilizou o Excel para construir ou analisar uma tabela com os seus dados de interesse. Geralmente, as tabelas já tem a mesma estrutura de um Data Frame, conceito que será muito útil em seus trabalhos e será apresentado aqui. Em um Data Frame cada registro será inserido em uma linha, já as colunas representarão as suas variáveis. Por exemplo, em uma pesquisa de opinião, as informações de uma linha serão os dados de uma pessoa respondente específica. Enquanto cada coluna da tabela corresponderá as respostas para uma pergunta específca. Diferentemente de uma matriz tradicional, as colunas podem misturar vários tipos de variáveis. No caso da pesquisa de opinião, pode-se ter uma coluna para Idade (variável numérica), outra para o Gênero (variável categórica) e outra pergunta aberta (variável de texto). Regras básicas de um Data Frame: Cada coluna deve ter um nome Todas as colunas devem ser do mesmo tamanho. Não é permitido que uma coluna tenha 40 registros e outra 39. As colunas podem ser numéricas (numeric), categóricas (factor) ou texto (character) Sempre terão duas dimensões (linhas e colunas) 7.2 Manipulação de um Data Frame Seja qual for a sua área dentro da Ciência de Dados, os conceitos a seguir serão muito úteis e irão facilitar muito a vida em suas análises. Seja para econometria, bioestatística, demografia, machine learning ou qualquer outra. O melhor pacote do R para manipular dados para manipular Data Frames se chama dplyr. Porque usar o dplyr: Facilidade de criação e leitura do código - Código limpo. Manipulação básica ou avançada em poucas linhas É muito mais veloz comparando com as funções correspondentes de outros pacotes. É simples. Baseado em apenas 6 funções principais. 7.3 As funções do Dplyr O Dplyr é bastante conhecido e usado pelos 6 verbos que representam suas principais funções: Summarise -&gt; Calcula valores para uma coluna. Ex: mínimo, máximo, média, desvio padrão, etc. Mutate -&gt; Cria uma nova variável que seja uma função entre variáveis que já existem Select -&gt; Seleciona colunas que já existem pelo nome delas. Filter -&gt; Selectiona registros (linhas) de acordo com uma condição estabelecida. Arrange -&gt; Ordena as linhas do data frame. Rename -&gt; Renomear o nome das variáveis. Essas são as principais funções que você irá utilizar em uma manipulação de dados. Apesar de serem simples, são muito poderosas. 7.4 As propriedades das funções do pacote Dplyr Esses conceitos apresentados agora irão facilitar muito o seu entendimento para qualquer uma das funções usadas no pacote. Características comuns as funções citadas do pacote: O primeiro argumento da função é sempre o seu conjunto de dados que será manipulado. Os argumentos seguintes vão definir o que será feito com o seu conjunto de dados O resultado também será um data frame. Ao inserir os nomes de colunas (variáveis) não é necessário (e nem permitido) usar \"\" ou o operador $. Na prática será bem fácil identificar esse padrão. Então, vamos ver como funciona cada uma das funções. 7.5 A função Summarise e a função group_by A função summarise é útil para calcular estatísticas das colunas de um data frame. Muitas vezes é utilizada com uma função auxiliar também muito importante: a função group_by. Suponha que você tenho um conjunto de dados com vários carros (cada carro será uma linha) e várias características dos carros (colunas). Para calcular a média de uma dessas características, por exemplo a quantidade de cavalos dos carros, você usaria a função summarise. Mas imagine agora que você não precisa simplesmente calcular a quantidade de cavalos de todos os carros, você precisar calcular essa média de acordo com a quantidade de cilindros dos carros. Nesse caso, a função group_by irá separar seus dados de acordo com uma variável (quantidade de cilindros) e assim você poderá usar a função summarise para calcular a média da quantidade de cavalos. Vamos usar o mtcarts - dataset nativo no R. Para mais informações sobre as variáveis do dataset, execute o comando ?mtcarts library(dplyr) ## Warning: package &#39;dplyr&#39; was built under R version 3.6.3 ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union mtcars_grupo&lt;-group_by(mtcars,cyl) ##a variável cyl é a quantidade de cilindros do carro summarise(mtcars_grupo,mean(hp)) ## a variável hp é a quantidade de cavalos do carro (horse power) ## # A tibble: 3 x 2 ## cyl `mean(hp)` ## &lt;dbl&gt; &lt;dbl&gt; ## 1 4 82.6 ## 2 6 122. ## 3 8 209. Caso você deseje continuar trabalhando com o mesmo dataset (usando o mesmo objeto), é importante que você desfaça o agrupamento. Isso irá evitar futuros erros na execução do seu código. # desagrupando o data frame mtcars_grupo&lt;-ungroup(mtcars_grupo) 7.6 Mutate A função mutate serve para criar uma nova coluna que seja uma função entre as variáveis que já existem. Então, usando o mesmo data frame mtcars, temos a variável wt que representa o peso do carro (em libras) e a variável qsec que representa o tempo (em segundos) que o carro precisa para percorrer a distância de 0,25 milhas. Portanto, como exemplo, vamos criar uma nova coluna para relativizar o tempo que o carro gasta para percorrer 0,25 milhas (qsec) pelo seu peso (wt). A fómula para isso seria: qsec/wt. O nome da nova coluna será tempo_peso. Portanto: library(dplyr) novo_dataframe&lt;-mutate(mtcars,tempo_peso = qsec/wt) # a função irá adicionar a nova coluna e atribuir ao seu data frame 7.7 Select A função select serve para selecionar colunas em um data frame. Então, ainda usando o dataframe mtcars, suponha que somente as variáveis mpg e gear serão úteis em nossa análise. Para filtrar essas variáveis, precisamos executar o seguinte comando: select(mtcars,mpg,gear) ## mpg gear ## Mazda RX4 21.0 4 ## Mazda RX4 Wag 21.0 4 ## Datsun 710 22.8 4 ## Hornet 4 Drive 21.4 3 ## Hornet Sportabout 18.7 3 ## Valiant 18.1 3 ## Duster 360 14.3 3 ## Merc 240D 24.4 4 ## Merc 230 22.8 4 ## Merc 280 19.2 4 ## Merc 280C 17.8 4 ## Merc 450SE 16.4 3 ## Merc 450SL 17.3 3 ## Merc 450SLC 15.2 3 ## Cadillac Fleetwood 10.4 3 ## Lincoln Continental 10.4 3 ## Chrysler Imperial 14.7 3 ## Fiat 128 32.4 4 ## Honda Civic 30.4 4 ## Toyota Corolla 33.9 4 ## Toyota Corona 21.5 3 ## Dodge Challenger 15.5 3 ## AMC Javelin 15.2 3 ## Camaro Z28 13.3 3 ## Pontiac Firebird 19.2 3 ## Fiat X1-9 27.3 4 ## Porsche 914-2 26.0 5 ## Lotus Europa 30.4 5 ## Ford Pantera L 15.8 5 ## Ferrari Dino 19.7 5 ## Maserati Bora 15.0 5 ## Volvo 142E 21.4 4 Então, o primeiro argumento é o dataset (mtcars) e os argumentos restantes na função select são as colunas que você deseja manter. 7.8 Filter Enquanto a função select seleciona as colunas do dataframe, a função filter é utilizada para selecionar as linhas do dataframe. Então, quando precisamos selecionar registros de um data frame usando determinada condição, a função recomendada é a filter. Utilizando o mesmo data frame, suponha que precisamos filtrar todos os carros com 6 cilindros. Neste caso, a variável em questão é a cyl, então a nossa condição é que o registro atenda a condição cyl==6. Repare que o sinal de igual é duplo, pois é uma condição lógica. Quando usamos cyl=6 estamos atribuindo o valor 6 para o objeto cyl. Mas não é o que desejamos aqui. Desejamos filtrar os dados por uma condição lógica (verdadeira ou falsa). Para fazer testes lógicos no R, usamos == para retornar TRUE caso os valores sejam iguais e FALSE caso os valores sejam diferentes. Quando for necessário inverter a lógica e buscar pelos valores diferentes (ao invés de buscar os iguais) o teste lógico será feito por “!=” (testa se os valores são diferentes). Então, em nosso exemplo, o código seria o seguinte: filter(mtcars,cyl==6) #filtra todos as observações (carros) que possuem 6 cilindros. ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## 3 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## 4 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## 5 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 ## 6 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 ## 7 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 Também é possível combinar outros operadores lógicos quando vamos filtrar os dados, como E/OU. Então, suponha que não basta que o carro tenha 6 cilindros, além disso você deseja que ele tenha menos que 3 toneladas. Neste caso, o peso do carro é representado pela variável wt. Para filtrar os carros que tenham 6 cilindros (cyl==6) e tenham menos que 3 toneladas (wt&lt;3), vamos executar o seguinte código: filter(mtcars,cyl==6 &amp; wt&lt;3) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## 3 19.7 6 145 175 3.62 2.770 15.50 0 1 5 6 O operador lógico E é representado pelo símbolo &amp;. Já o operador lógico OU é representado pelo símbolo |. Caso o objetivo fosse filtrar carros com 6 cilindros OU peso menor que 3 toneladas, o código seria o seguinte: filter(mtcars,cyl==6 | wt&lt;3) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## 3 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## 4 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## 5 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## 6 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 ## 7 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 ## 8 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## 9 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 ## 10 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 ## 11 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 ## 12 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 ## 13 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 ## 14 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## 15 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 ## 16 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 Para a condição “cyl==6 | wt&lt;3” ser verdadeira, basta que pelo menos uma das condições sejam atingidas. Ou seja, o carro tenha 6 cilindros ou menos de 3 toneladas. Caso as duas condições sejam atendidas simultaneamente o carro também estará na tabela filtrada. 7.9 Arrange A função arrange é responsável por ordenar as linhas do data frame seguindo uma nova ordem estabelecida. Então, suponha que em nosso exemplo, queremos ordenar o data frame mtcars do carro com menor número de marchas para o maior número de marchas. Porém, há vários carros que irão empatar para esse critério, já que a tabela tem 15 carros com 3 marchas, 12 carros com 4 marchas e 5 carros com 5 marchas. table(mtcars$gear) ## ## 3 4 5 ## 15 12 5 Portanto, vou definir que os dados também sejam ordenados pelo peso (variável wt). arrange(mtcars,gear,wt) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 ## 2 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## 3 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 ## 4 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 ## 5 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## 6 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 ## 7 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 ## 8 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 ## 9 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 ## 10 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 ## 11 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 ## 12 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 ## 13 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 ## 14 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 ## 15 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 ## 16 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 ## 17 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 ## 18 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 ## 19 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## 20 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## 21 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## 22 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 ## 23 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## 24 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## 25 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## 26 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 ## 27 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 ## 28 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## 29 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 ## 30 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 ## 31 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 ## 32 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 É possível usar a função arrange para ordenar os dados usando muitas variáveis para ordenar os dados. Porém, a ordem que as colunas forem inseridas na função arrange representam uma ordem de prioridade. Portanto, a função só irá ordenar pela segunda coluna caso haja empates na primeira, por exemplo. 7.10 Rename Alterar os nomes de uma variável de um data frame é algo conceitualmente simples. Mas, na prática pode ser bem trabalhoso de fazer sem a função rename. Quais são os nomes das colunas da tabela mtcats? names(mtcars) ## [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; ## [11] &quot;carb&quot; Agora suponha que você deseje alterar o nome da coluna cyl para cilindros e hp para cavalos. mtcars_&lt;-rename(mtcars,cilindros=cyl,cavalos=hp) head(mtcars_) ## mpg cilindros disp cavalos drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 Esse é o padrão. Após informar o data frame onde se aplicará as alterações, coloca-se o novo nome da coluna antes do sinal de igual e logo após o nome antigo da coluna. 7.11 O operador %&gt;% (leia-se pipe) O operador %&gt;% facilita muito a nossa vida, tornando o código mais limpo e fácil de ser compreendido. O operador funciona da seguinte forma: # dataset %&gt;% função() Isso significa que o objeto do lado esquerdo do operador (dataset) será inserido na função ao lado direito do operador no primeiro argumento da função. O operador %&gt;% pode ser usado conjuntamente com inúmeras funções, incluindo todas que aprendemos nesse capítulo. Exemplos práticos: Algumas linhas atrás, ordenamos o dataset mtcars em ordem crescente pelas colunas gear e wt, usando o código: dataset_ordenado &lt;- arrange(mtcars,gear,wt) Utilizando o operador %&gt;%, o código ficaria da seguinte maneira: dataset_ordenado &lt;- mtcars %&gt;% arrange(gear,wt) Então, o dataset mtcars é inserido no primeiro argumento da função arrange. A diferença é pequena para casos simples como esse, porém em casos mais complexos a utilização do operador %&gt;% (pipe) fará uma diferença enorme na organização do seu código. www.luisotavio.pro "],
["manipulação-de-hora-e-data.html", " 8 Manipulação de Hora e Data 8.1 Formato de data no R 8.2 Extrair ano, mês, dia, horas, minutos ou segundos. 8.3 Fuso horário 8.4 Operação com datas", " 8 Manipulação de Hora e Data Existem algumas peculiaridades para tratar hora e data nas linguagens de programação, por isso, resolvi separar um capítulo só para isso. Vamos fazer isso da maneira mais simples possível e de forma que você resolva todos os problemas que vai encontrar na prática. Uma questão que devemos estar atentos é o formato que estão os nossos dados. Isso porque existem vários formatos para a variável data e hora. Por exemplo, você pode importar os seus dados em qualquer uma das formas a seguir: 15/01/2019 13:10:57 (dia, mês, ano com 4 dígitos, horas, minutos e segundos) 01/15/17 13:10 (mês, dia, ano com 2 dígitos, horas e minutos) 15 Novembro 2019 (dia, mês por extenso e ano com 4 dígitos) Enfim, cada fonte de dados irá definir um padrão de hora e data diferente. Porém, o R tem um formato padrão que irá facilitar a manipulação dos dados. 8.1 Formato de data no R O formato tradicional usado no R para data e hora é o seguinte: 2019-11-30 15:33:51 (ano com 4 dígitos, mês, dia, hora, minutos e segundos) ou, somente a data: 2019-11-30 (ano com 4 dígitos, mês, dia) Isso quer dizer que quando os seus dados tiverem uma variável de hora e data, é recomendável transformá-la para o formato padrão do R caso você queira usá-la. 8.1.1 Como transformar o formato da variável de data e hora? Para transformar os seus dados originais de data e hora para o formato padrão do R, basta informar ao R qual é o padrão original. Ou seja, se os dados que você importou para o R seguem o padrão 13-01-2019, basta definir que o formato é dia, mês e ano com 4 dígitos. Isso já irá transformar a variável para padrão do R. Vamos ver na prática: date&lt;-c(&quot;13-01-2019&quot;) strptime(date,format=&quot;%d-%m-%Y&quot;) ## [1] &quot;2019-01-13 -03&quot; Quando definimos que o formato original dos dados é “%d-%m-%Y”, estamos avisando ao R que originalmente a nossa variável de data está no formato dia (%d), mês (%m) e ano com 4 dígitos (%Y). Com essa informação, o R irá transformar a nossa variável de data para o formato padrão. Importante: Para saber cada letra que irá representar o formato da sua variável de data, basta pesquisar com o comando: ?strptime São muitas possibilidades diferentes e, com certeza, não vale a pena gastar tempo memorizando cada uma delas. Também é importante reparar que a data foi importada como character e transformada para a classe date. Vamos ver um outro exemplo: date2&lt;-c(&quot;10 Dezembro 2017&quot;) class(date2) ## a classe do objeto date2 é character ## [1] &quot;character&quot; date2_R &lt;- strptime(date2, &quot;%d %B %Y&quot;) class(date2_R) ## [1] &quot;POSIXlt&quot; &quot;POSIXt&quot; date2_R ## [1] &quot;2017-12-10 -03&quot; Então, quando eu aviso ao R que o formato original da variável de data é “%d %B %Y”, estou falando que primeiro é o dia (%d), depois o mês por extenso (%B) e depois o ano com 4 dígitos (%Y). Desta forma, o R irá transformar a variável para o padrão da linguagem. Além disso, o objeto que era da classe character, é transformado para Date. Novamente, aproveito para te lembrar que executar o comando ?strptime e ler sua documentação é a maneira mais fácil para saber quais símbolos você deve usar para transformar do formato original dos seus dados para o padrão do R. Quando os seus dados também tiverem os valores de horário, o raciocínio é o mesmo: data_hora&lt;-c(&quot;22 Janeiro 17, 17:12:53&quot;) data_hora &lt;- strptime(data_hora, &quot;%d %B %y, %H:%M:%S&quot;) data_hora ## [1] &quot;2017-01-22 17:12:53 -03&quot; 8.2 Extrair ano, mês, dia, horas, minutos ou segundos. Em alguns casos, precisaremos desmembrar as informações de data e hora. Isso é necessário quando o nosso único interesse é trabalhar com o ano, por exemplo. Portanto, vamos aprender como extrair o ano, mês, dia, hora, minuto ou segundo da variável de datae hora. Irei considerar que a nossa variável de data e hora já foi transformada para o padrão do R, como demonstado no item anterior. data_hora #variável definida no exemplo anterior ## [1] &quot;2017-01-22 17:12:53 -03&quot; #extrair apenas o ano: format(data_hora,&quot;%Y&quot;) ## [1] &quot;2017&quot; #extrair apenas o mês: format(data_hora,&quot;%m&quot;) ## [1] &quot;01&quot; #extrair apenas o dia: format(data_hora,&quot;%d&quot;) ## [1] &quot;22&quot; #extrair apenas a hora: format(data_hora,&quot;%H&quot;) ## [1] &quot;17&quot; #extrair apenas o minuto: format(data_hora,&quot;%M&quot;) ## [1] &quot;12&quot; #extrair apenas o segundo: format(data_hora,&quot;%S&quot;) ## [1] &quot;53&quot; Caso seja interessante em sua análise extrair mais um valor ao mesmo tempo, é só seguir o mesmo raciocínio. Para extrair apenas a horas e os minutos: #extrair apenas as horas e os minutos format(data_hora,&quot;%H:%M&quot;) ## [1] &quot;17:12&quot; 8.3 Fuso horário Em alguns casos vamos precisar alterar o fuso horário da nossa variável de data. Casos mais comuns: O R foi configurado no seu computador como se você não estivesse onde você realmente está. Por exemplo, por algum motivo as suas configurações de locale estão em Inglês e o fuso horário corresponde ao fuso horário de Londres. Isso será super comum caso você utilize o R na nuvem, uma vez que possivelmente o servidor de nuvem não estará no mesmo fuso horário que o seu. Caso os horários do seu banco de dados esteja em um fuso horário diferente do que você deseja trabalhar, seja porque você está trabalhando com dados mundiais ou qualquer outro motivo. Para resolver isso, é bem simples. Veja o exemplo: ## Vamos atribuir ao objeto hora_londres um horário registrado considerando o fuso horário de Londres hora_londres &lt;- &quot;2019-07-03 18:30&quot; ## Vamos atribuir o fuso horário ao objeto. Pois o R ainda não sabia qual o fuso horário do objeto hora_londres. hora_londres &lt;- as.POSIXct(hora_londres, tz=&quot;Europe/London&quot;) ## Criando um novo objeto com o mesmo valor hora_sao_paulo&lt;-hora_londres ## Transformando o fuso horário do objeto hora_sao_paulo attributes(hora_sao_paulo)$tzone &lt;- &quot;America/Sao_Paulo&quot; # hora do objeto hora_londres hora_londres ## [1] &quot;2019-07-03 18:30:00 BST&quot; # hora do objeto hora_sao_paulo hora_sao_paulo ## [1] &quot;2019-07-03 14:30:00 -03&quot; Portanto, o valor do objeto hora_sao_paulo é 4 horas mais cedo do que o do objeto hora_londres. O valor ‘-03’ no objeto hora_sao_paulo se refere ao GMT -3, fuso horário típico do Brasil e de São Paulo. 8.4 Operação com datas Vamos considerar os objetos que já utilizamos nesse capítulo para calcular a diferença entre eles: hora_sao_paulo ## [1] &quot;2019-07-03 14:30:00 -03&quot; data_hora ## [1] &quot;2017-01-22 17:12:53 -03&quot; hora_sao_paulo - data_hora ## Time difference of 891.8869 days Como os dois objetos estão no formato padrão do R, é possível fazer a subtração de forma direta (hora_sao_paulo - data_hora). Caso seja interessante você definir qual a medida do resultado de diferença entre as datas, use a função difftime. diferenca_horas &lt;- difftime(hora_sao_paulo, data_hora, units=&#39;hours&#39;) diferenca_horas ## Time difference of 21405.29 hours No exemplo acima, defini que gostaria de ter a resposta de diferença entre as datas em horas (units=‘hours’). Também é possível somar ou subtrair valores do seu objeto de data e hora. Suponha que desejamos somar 1 hora no objeto data_hora: data_hora ## [1] &quot;2017-01-22 17:12:53 -03&quot; data_hora + 60*60 ## [1] &quot;2017-01-22 18:12:53 -03&quot; A menor unidade do objeto é um segundo. Ou seja, quando adicionamos 60 unidades, estamos adicionando 1 minuto. Quando adicionamos 60*60 estamos adicionando 60 vezes 1 minuto, portanto adicionamos 1 hora. Agora um exemplo com apenas datas: data_inicio&lt;-strptime(&quot;10 Dezembro 2017&quot;, format=&quot;%d %B %Y&quot;) data_fim&lt;-strptime(&quot;17 Dezembro 2018&quot;, format=&quot;%d %B %Y&quot;) data_fim - data_inicio ## Time difference of 372 days Para somar 2 dias ao objeto que contém as datas, devemos somar o valor de 2*60*60*24. 60*60 representa a quantidade de segundos em 1 hora. Já 24 representa as 24 horas do dia. Então, para adicionar dois dias, devemos multiplicar 2 por 60*60*24. data_inicio + 2*60*60*24 ## [1] &quot;2017-12-12 -03&quot; www.luisotavio.pro "],
["estruturas-de-controle.html", " 9 Estruturas de Controle 9.1 for 9.2 while 9.3 if - else 9.4 ifelse", " 9 Estruturas de Controle Duas das principais vantagens da maioria das linguagens computacionais são: Executar tarefas repetitivas Fazer decisões lógicas Para executar tarefas repetitivas, vamos criar loopings. É como se o nosso código desse voltas e repetisse de acordo com a regra estabelecida. Os loopings irão usar as funções for e while. Para adicionar decisões lógicas ao nosso algoritmo, as principais funções são o if-else e o ifelse. Existem outras estruturas de controle que não serão abordadas aqui. Porém essas são as mais importante. As estruturas de controle podem ser combinadas quando necessário. Ou seja, você pode utilizar a função for juntamente com outra função for. Ou então a função while juntamente com a função if. Essas combinações irão depender somente da demanda do algoritmo que você precisa desenvolver. 9.1 for A função for é usada para criar loopings, ou seja, para executar uma tarefa diversas vezes. Para usar a função for, você precisa criar uma variável para te auxiliar. Essa variável terá o seu valor alterado a cada ciclo de execução do for. Além disso, essa variável irá percorrer uma sequência, definida por você. Veja na prática: Vamos criar um vetor que irá receber o valor do dobro de sua posição. Esse vetor irá ter tamanho igual a 10. nosso_vetor&lt;-c() #criei o &#39;nosso_vetor&#39; for(posicao in 1:10){ #a nossa variável auxiliar é a &#39;posicao&#39;. Ela irá percorrer o vetor 1:10. #O vetor 1:10 é a mesma coisa que criar um vetor com todos os números de 1 a 10. #O primeiro valor para a variável &#39;posicao&#39; será 1, depois 2 até o último valor que é 10. nosso_vetor[posicao]&lt;-2*posicao #O vetor &#39;nosso_vetor&#39; irá receber o dobro de sua posição. } nosso_vetor ## [1] 2 4 6 8 10 12 14 16 18 20 Outro exemplo: for(auxiliar in 1:10){ print(nosso_vetor[auxiliar]) } ## [1] 2 ## [1] 4 ## [1] 6 ## [1] 8 ## [1] 10 ## [1] 12 ## [1] 14 ## [1] 16 ## [1] 18 ## [1] 20 No exemplo acima, a nossa variável auxiliar também irá percorrer a sequência 1, 2, 3, 4, 5, 6, 7, 8, 9 e 10. A tarefa a ser repetida é imprimir o elemento dentro do ‘nosso_vetor’ que está posicionado no valor da variável ‘auxiliar’. A variável irá percorrer o looping começando com valor igual a 1 e irá até o valor 10. Ou seja, o que o looping faz é exatamente equivalente ao código: print(nosso_vetor[1]) ## [1] 2 print(nosso_vetor[2]) ## [1] 4 print(nosso_vetor[3]) ## [1] 6 print(nosso_vetor[4]) ## [1] 8 print(nosso_vetor[5]) ## [1] 10 print(nosso_vetor[6]) ## [1] 12 print(nosso_vetor[7]) ## [1] 14 print(nosso_vetor[8]) ## [1] 16 print(nosso_vetor[9]) ## [1] 18 print(nosso_vetor[10]) ## [1] 20 9.2 while Note que a função for segue uma sequência já definida antes do início do looping. A variável auxiliar percorre essa sequência e elas não sofrem nenhuma alteração pelo código dentro do for. Porém, em alguns casos, vai ser mais interessante manter o looping rodadando enquanto alguma condição ainda não foi atendida. Para isso usaremos a função while. Esse é o caso, por exemplo, de um modelo de previsões que irá sofrer um número indefinido de iterações e só irá encerrar o looping quando o erro for menor do que determinado valor. i&lt;-0 while(i &lt; 1){ i&lt;-rnorm(1) #a função rnorm(1) irá gerar 1 número aleatório com a distribuição normal padrão. print(i) #a função print(i) irá imprimir o valor atribuído a i na linha anterior. } ## [1] -1.732571 ## [1] 0.3026057 ## [1] 0.5825827 ## [1] 0.9455167 ## [1] -0.6268171 ## [1] 0.9370093 ## [1] -0.2560758 ## [1] 0.4265669 ## [1] -0.572934 ## [1] -0.4839314 ## [1] -0.9907221 ## [1] -0.3772552 ## [1] -1.43094 ## [1] 3.052486 A condição para o looping acontecer é que o valor de i seja menor do que 1. A cada nova interação, o valor de i é atualizado por um novo valor. A função print(i) imprime o valor atribuído ao elemento i. Então, o looping irá dar voltas enquanto o valor de i for menor do que 1. O último valor impresso é maior do que 1 e isso significa que a condição i &lt; 1 não é mais atendida e o looping irá se encerrar. 9.3 if - else As funções for e while são úteis para criarmos loopings e repetir determinada tarefa. Já as funções if ou ifelse são funções de decisões lógicas. Ou seja, você irá estabelecer uma condição e, caso ela seja atentida, o código será executado. Caso a condição estabelecida seja atendida (TRUE), será seguido o roteiro estabelecido quando a condição for verdadeira. Caso a condição não seja atendida (FALSE), será seguido outro roteiro. Nesse item, vamos utilizar as funções if e else separadas, primeiro uma e depois a outra. O exemplo abaixo, vamos criar a condição lógica a &lt; b. Portanto, se a for menor que b, a condição lógica será verdadeira e a parte seguinte do código será executada: a&lt;-2 b&lt;-5 if(a &lt; b){ print(&quot;Condição verdadeira. &#39;a&#39; é menor que &#39;b&#39;&quot;) } ## [1] &quot;Condição verdadeira. &#39;a&#39; é menor que &#39;b&#39;&quot; Agora, vamos adicionar a função else que é simplemente o SENÃO. Caso a condição lógica seja FALSA, o script contido dentro da função else é executado. if(a &gt; b){ #a condição lógica foi invertida e será FALSA print(&quot;Condição verdadeira. &#39;a&#39; é maior que &#39;b&#39;&quot;) }else{ print(&quot;Condição falsa. &#39;a&#39; não é maior que &#39;b&#39;&quot;) } ## [1] &quot;Condição falsa. &#39;a&#39; não é maior que &#39;b&#39;&quot; O uso da função else é opicional. Caso ela não esteja presente, nada irá acontecer quando a condição lógica não for atendida. Repare que as duas formas apresentadas seguem os padrões: ## if if(condicao_logica){ #a condição lógica deve ser sempre TRUE ou FALSE #SCRIPT CASO A CONDIÇÃO FOR ATENTIDA } ## if - else if(condicao_logica){ #a condição lógica deve ser sempre TRUE ou FALSE #SCRIPT CASO A CONDIÇÃO FOR ATENTIDA (TRUE) }else{ #SCRIPT CASO A CONDIÇÃO NÃO FOR ATENTIDA (FALSE) } 9.4 ifelse O raciocínio lógico utilizado na função ifelse é o mesmo que aprendemos com as funções if e else. A função será utilizada da seguinte forma: ifelse(Condição,Ação se for a condição for verdadeira, Ação se a condição for falsa) Porém, a diferença é que a função ifelse é aplicada a um vetor. Isso a torna extremamente útil e facilitará a nossa vida em alguns casos. Exemplo: vetor&lt;-c(2,10,5,50,9,15,3,0,25) vetor2 &lt;- ifelse(vetor&lt;10,&quot;menor&quot;,&quot;MAIOR&quot;) vetor2 ## [1] &quot;menor&quot; &quot;MAIOR&quot; &quot;menor&quot; &quot;MAIOR&quot; &quot;menor&quot; &quot;MAIOR&quot; &quot;menor&quot; &quot;menor&quot; &quot;MAIOR&quot; A solução acima não pode ser aplicada ao método if-else ensinado no item anterior. if(vetor&lt;10){ vetor2&lt;-&quot;menor&quot; }else{ vetor2&lt;-&quot;MAIOR&quot; } ## Warning in if (vetor &lt; 10) {: a condição tem comprimento &gt; 1 e somente o ## primeiro elemento será usado vetor2 ## [1] &quot;menor&quot; Portanto, caso precise usar uma função condicional para vetores, a função ifelse é uma das opções que você deve considerar. Lembre também que caso você esteja trabalhando com um data frame, cada coluna de seu data frame pode ser tratada como um vetor. A seguir vamos criar uma nova coluna em um data frame baseada em uma condição lógica: head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 # Suponha que o objetivo seja criar duas categorias de carros, os que gastam muito combustível e os que gastam pouco. # para isso, vamos usar a variável mpg (milhas por galão). mtcars$consumo_combustivel&lt;-ifelse(mtcars$mpg&lt;20,&quot;Bebe muito&quot;,&quot;Bebe pouco&quot;) head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 ## consumo_combustivel ## Mazda RX4 Bebe pouco ## Mazda RX4 Wag Bebe pouco ## Datsun 710 Bebe pouco ## Hornet 4 Drive Bebe pouco ## Hornet Sportabout Bebe muito ## Valiant Bebe muito Então, colocamos as colunas (que são vetores) do data frame mtcars como argumentos da função ifelse. www.luisotavio.pro "],
["explore-os-seus-dados.html", " 10 Explore os seus dados 10.1 Nome das colunas 10.2 Estrutura do Dataset 10.3 O começo e o final do seu conjunto de dados 10.4 Frequência 10.5 Estatísticas descritivas básicas 10.6 Gráficos usados na Análise Exploratória", " 10 Explore os seus dados Existem dois grandes motivos para você explorar os seus dados antes de realmente começar uma análise mais profunda: Conhecer um pouco mais dos dados que você irá trabalhar. Isso pode te ajudar a eliminar conceitos formados simplesmente pelo achismo e realmente começar a analisar os números. Ao explorar e conhecer melhor os dados, você também estará mais familiarizado com os dados e será mais fácil planejar ou, quando necessário, adaptar o seu projeto. Verificar possíveis erros ou valores inconsistentes nos seus dados. É nessa fase de análise exploratória que você irá descobrir caso seus dados possuam valores ilógicos ou caso a sua variável numérica esteja classificada como texto, o que iria te impedir de realizar cálculos com ela. Nesse capítulo irei mostrar os principais passos de uma Análise Exploratória. Primeiramente, você deve ler os seus dados no RStudio. Como esse passo já foi explicado no Capítulo 6, vamos pular essa parte. Vamos trabalhar com um Dataset bem conhecido na Ciência de Dados, seu nome é iris. O Dataset possui as medidas de 150 flores pertencentes a 3 diferentes espécies. Para explicar um pouco sobre o Dataset, já vou usar uma função que pode ser utilizada na sua exploração: a função names(). Usamos essa função para conhecer os nomes das variáveis (colunas) do dataset. 10.1 Nome das colunas names(iris) ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; &quot;Species&quot; A primeira coluna representa o comprimento da sépala da flor (“Sepal.Length”), já a segunda coluna é largura da sépala(“Sepal.Width”). A terceira coluna mostra o valor do comprimento da pétala (“Petal.Length”) e a quarta a largura da pétala (“Petal.Width”). A última coluna indica qual a espécie da flor. 10.2 Estrutura do Dataset Possivelmente este será o primeiro comando que você irá executar ao receber um Dataset novo str(). A função str() mostra qual a estrutura de um objeto. str(iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... Então, de forma simples, podemos ver que temos um data frame com 150 observações e 5 variáveis. Além disso, já sabemos que as 4 primeiras variáveis são numéricas (num) e a variável Species é categórica (Factor) e possui 3 diferentes categorias (Factor w/ 3 levels). 10.3 O começo e o final do seu conjunto de dados Se tiver algum problema na importação dos seus dados para o R/Rstudio, é bem provável que você consiga notar isso avaliando as primeiras ou as últimas linhas de seu conjunto de dados. # As primeiras linhas do seu conjunto de dados head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa # As últimas linhas do seu conjunto de dados tail(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 145 6.7 3.3 5.7 2.5 virginica ## 146 6.7 3.0 5.2 2.3 virginica ## 147 6.3 2.5 5.0 1.9 virginica ## 148 6.5 3.0 5.2 2.0 virginica ## 149 6.2 3.4 5.4 2.3 virginica ## 150 5.9 3.0 5.1 1.8 virginica 10.4 Frequência A frequência é utilizada para conhecer melhor as variáveis categóricas. Porém, também é muito importante para encontrar erros em nossos dados. Para encontrar erros utilizando a frequência, pressupõe-se que você tenha algum conhecimento prévio dos dados e possa assim identificar frequencias discrepantes em alguma categoria. Também pode ser o caso de notar que uma das categorias deveria estar em seu conjunto de dados e não está. Primeiramente, iremos utilizar a função table() para calcular a frequência de cada categoria da variável Species. table(iris$Species) ## ## setosa versicolor virginica ## 50 50 50 A frequência também pode ser calculada utilizando o pacote dplyr: library(dplyr) iris %&gt;% count(Species) ## # A tibble: 3 x 2 ## Species n ## &lt;fct&gt; &lt;int&gt; ## 1 setosa 50 ## 2 versicolor 50 ## 3 virginica 50 Caso não se lembre do operador pipe (%&gt;%), releia a última parte do Capítulo de Manipulação de Dados. 10.5 Estatísticas descritivas básicas A frequência mostrada no item anterior é útil para variáveis categóricas. Porém, para variáveis numéricas, faz muito mais sentido que se calcule algumas estatísticas básicas. Repito, essa exploração tem dois objetivos: conhecer melhor os seus dados e prevenir que o conjunto de dados tenha algum valor discrepante que seja totalmente ilógico (ou seja, um erro). As variáveis numéricas do conjunto de dados iris são: Sepal.Length, Sepal.Width, Petal.Length e Petal.Width. As estatísticas básicas podem ser simplesmente calculadas pela função summary summary(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species ## setosa :50 ## versicolor:50 ## virginica :50 ## ## ## Portanto, a função retornou as seguintes estatísticas para as variáveis numéricas: Valor mínimo 1º quartil (Valor que é maior do que 25% dos dados e menor do que os 75% restantes) Mediana (Valor que é maior que 50% dos dados e menor do que os 50% restantes) Média 3º quartil (Valor que é maior do que 75% dos dados e menor do que os 25% restantes) Valor máximo Para a variável categórica Species, foram retornadas as frequências de cada categoria. 10.6 Gráficos usados na Análise Exploratória Existem dois gráficos muito comuns para explorar uma variável e visualizar a distribuição de seus dados: Histograma BoxPlot 10.6.1 Histograma O Histograma é um gráfico de frequência e mostra onde há maior concentração de valores. Esse é o histograma para a variável Sepal.Length: hist(iris$Sepal.Length) 10.6.2 Boxplot O Boxplot (ou gráfico de caixa) representa graficamente o valor mínimo, o 1º quartil, a media, o 3º quartil e o valor máximo de uma variável. Esse é o Boxplot para a variável Petal.Width: boxplot(iris$Petal.Width) www.luisotavio.pro "],
["criando-gráficos-no-r.html", " 11 Criando Gráficos no R 11.1 Criando gráficos com a biblioteca ggplot2", " 11 Criando Gráficos no R A comunicação dos resultados talvez seja a parte mais importante do trabalho de um cientista de dados. Digo isso porque sem apresentar seus resultados de forma eficiente e clara, todo o trabalho desenvolvido é inútil. A visualização de dados, representada por gráficos, é praticamente indispensável em qualquer apresentação de um projeto desenvolvido por um Cientista de Dados. Certamente as cores e os tamanhos das barras, colunas ou qualquer outra representação vão facilitar muito o entendimento da mensagem que você deseja apresentar. E posso te garantir que somos extremamente bem servidos quando o assunto é visualização de dados com a linguagem R. Existe uma grande quantidade de bibliotecas que podemos usar para fazer gráficos realmente muito bonitos, claros e que irão surpreender os leitores de seus relatórios ou dashboards. Não é o objetivo desse e-book falar sobre todas essas bibliotecas, mas vou citar aqui as minhas favoritas: ggplot2 plot.ly googleVis rCharts leaflet Dentre as 5 possibilidades aqui citadas, destaco a primeira: ggplot2. Iremos aprofundar mais nessa biblioteca pela quantidade de possibilidades que ela nos trás. Usando a biblioteca `ggplot2 você irá conseguir fazer praticamente todos os tipos de gráficos disponíveis e com enorme capacidade de customização do seu gráfico. A medida que você for dominando a linguagem R, sugiro que também explore outras bibliotecas. Muitas vezes as bibliotecas plot.ly, googleVis e rCharts irão te possibilitar a criação de gráficos mais chamativos do que a biblioteca ggplot2. Eu costumo escolher a biblioteca que irei usar de acordo com o gráfico que desejo fazer. A biblioteca leaflet, por exemplo, é específica para a construção de mapas interativos. 11.1 Criando gráficos com a biblioteca ggplot2 Os gráficos da biblioteca partem de uma ideia bem simples: Todos os gráficos podem ser construídos com 3 elementos: O conjunto de dados Um sistema de coordenadas As marcas de representação visual (linhas, colunas, pontos, etc) Na prática, veremos como podemos criar um gráfico simples e depois ir aperfeiçoando e personalizando de acordo com a nossa necessidade. Esse aperfeiçoamento acontece com novas linhas de código, que são acrescentadas ao gráfico que já foi criado. Instalando o pacote ggplot2: install.packages(&quot;ggplot2&quot;) 11.1.1 Seu primeiro gráfico O código a seguir é dividido com os 3 elementos que citamos acima. O primeiro elemento é o conjunto de dados mtcars. Dataset que contém informações de diferentes modelos de carros. O segundo elemento está dentro da função aes(), que é usada para definir a estética do gráfico (abreviação para aesthetics - estética em inglês). Nesse elemento, definimos os eixos do gráfico. O gráfico irá mostrar a relação entre duas variáveis. A variável mpg (miles per gallon - Milhas percorridas para 1 galão de combustível) e wt (Weight - peso do carro). A variável mpg será alocada no eixo x (horizontal) e a variável wt no eixo y (vertical). O terceiro elemento são as marcas de representação visual do gráfico e são definidos pela função geom_point(). Como nesse exemplo não há nenhuma customização, a função geom_point() será vazia. library(ggplot2) ggplot(mtcars, aes(mpg, wt)) + geom_point() 11.1.2 Incrementando o gráfico Podemos incrementar um pouco o nosso gráfico adicionando uma terceira variável. Vamos adicionar a variável cyl, que representa o número de cilindros do carro. Agora, com 3 variáveis, o gráfico continuará sendo bi-dimensional. Porém, os pontos do gráfico serão coloridos de acordo com a variável cyl. Antes de criarmos o gráfico, segue uma consideração: a variável cyl está classificada como numérica. class(mtcars$cyl) ## [1] &quot;numeric&quot; Os carros desse dataset possuem 4, 6 ou 8 cilindros. Então, nesse caso será mais interessante tratar a variável cyl como categórica. Essa pequena alteração fará muita diferença na visualização dos dados, pois irá coloria cada uma das categorias com cores totalmente distintas. Caso se considerasse a variável cyl como numérica, as cores de cada quantidade de cilindros sofreria alterações apenas no tom da cor, dificultando a visualização de cada um dos grupos. Para tratar a variável cyl como categórica, vamos apenas adicionar a função factor() ao inserir a variável na criação do gráfico. library(ggplot2) ggplot(mtcars, aes(mpg, wt,color=factor(cyl))) + geom_point() Então, nesse último colocamos duas variáveis nos tradicionais eixos x e y - mpg e wt, respectivamente. Além disso, colorimos os pontos do gráfico de acordo com a quantidade de cilindros de cada carro. E se precisássemos adicionar mais informações a esse gráfico? 11.1.3 O Gráfico de Bolhas - Bubble Chart Além dessas 3 variáveis, se usarmos o gráfico de bolhas, poderemos adicionar uma 4ª variável ao nosso gráfico sem comprometer a sua qualidade. Então, a variável mpg será representada pelo eixo x, a variável wt pelo eixo y, as quantidade de cilindros serão destacadas por cores diferentes de cada bolha. A quarta variável escolhida é a qsec, que mede quantos segundos o carro precisa para alcançar 0,25 milhas. Em nosso gráfico, a variável qsec será representada pelo tamanho da bolha. Cada bolha é um ponto do gráfico e representa um carro do conjunto de dados. ggplot(mtcars, aes(mpg, wt))+ #definição de qual é o dataset e quais são as variáveis dos eixos x e y. geom_point(aes(color = factor(cyl), size = qsec), alpha = 0.5) + #definição de qual variável será representada pela cor e qual será representada pelo tamanho das bolhas. scale_color_manual(values = c(&quot;#00AFBB&quot;, &quot;#E7B800&quot;, &quot;#FC4E07&quot;)) + #definição das cores das bolhas. scale_size(range = c(0.5, 12)) # Amplitude do tamanho das bolhas Pelos dois últimos gráficos, há fortes indícios que quanto maior o peso do carro (wt), menor é a quantidade de milhas que ele consegue percorrer com um galão de combustível. Além disso, parece haver uma relação entre a quantidade de cilindros e essas duas variáveis. Por exemplo, os carros com 4 cilindros parecem ser mais leves e rodar mais milhas com um galão de combustível. 11.1.4 O gráfico de correlação Para verificar a correlação entre as variáveis, podemos simplesmente uma tabela com a correlação entre elas: corr &lt;- round(stats::cor(mtcars), 1) #a função round é usada para arredondar as casas decimais do resultado. corr ## mpg cyl disp hp drat wt qsec vs am gear carb ## mpg 1.0 -0.9 -0.8 -0.8 0.7 -0.9 0.4 0.7 0.6 0.5 -0.6 ## cyl -0.9 1.0 0.9 0.8 -0.7 0.8 -0.6 -0.8 -0.5 -0.5 0.5 ## disp -0.8 0.9 1.0 0.8 -0.7 0.9 -0.4 -0.7 -0.6 -0.6 0.4 ## hp -0.8 0.8 0.8 1.0 -0.4 0.7 -0.7 -0.7 -0.2 -0.1 0.7 ## drat 0.7 -0.7 -0.7 -0.4 1.0 -0.7 0.1 0.4 0.7 0.7 -0.1 ## wt -0.9 0.8 0.9 0.7 -0.7 1.0 -0.2 -0.6 -0.7 -0.6 0.4 ## qsec 0.4 -0.6 -0.4 -0.7 0.1 -0.2 1.0 0.7 -0.2 -0.2 -0.7 ## vs 0.7 -0.8 -0.7 -0.7 0.4 -0.6 0.7 1.0 0.2 0.2 -0.6 ## am 0.6 -0.5 -0.6 -0.2 0.7 -0.7 -0.2 0.2 1.0 0.8 0.1 ## gear 0.5 -0.5 -0.6 -0.1 0.7 -0.6 -0.2 0.2 0.8 1.0 0.3 ## carb -0.6 0.5 0.4 0.7 -0.1 0.4 -0.7 -0.6 0.1 0.3 1.0 A tabela acima é muito informativa, porém, caso seja visualizada como um gráfico será muito mais fácil de compreendê-la. Para criar um gráfico com a correlação entre as variáveis, precisaremos fazer uma pequena transformação na tabela acima. A matriz será transformada em uma nova tabela com 3 colunas: duas colunas com os nomes das variáveis e a terceira coluna com o valor correspondente da correlação entre elas. Para isso, usaremos a biblioteca reshape2 e a função melt: # install.packages(&quot;reshape2&quot;) #caso vc não já tenha instalado a biblioteca reshape2, precisa executar essa linha. library(reshape2) ## Warning: package &#39;reshape2&#39; was built under R version 3.6.3 melted_corr &lt;- melt(corr) library(ggplot2) ggplot(data = melted_corr, aes(x=Var1, y=Var2, fill=value)) + geom_tile() 11.1.5 Aperfeiçoando o gráfico Os gráficos facilitam muito a visualização dos dados. Porém, com mais um pouco de esforço, podemos melhorar muito a visualização desses dados. corr[lower.tri(corr,diag = T)]&lt;- NA ## selecionar apenas a parte superior da matriz (evitando informações repetidas) library(reshape2) dados_correlacao &lt;- melt(corr,na.rm = T) #transformando os dados para as 3 colunas como anteriormente. library(ggplot2) ggplot(data = dados_correlacao, aes(Var2, Var1, fill = value))+ #seleciona os dados e as variáveis para cada eixo, assim como a variável que determina a cor (value). geom_tile(color = &quot;white&quot;)+ #definindo a cor do contorno de cada quadrado. scale_fill_gradient2(low = &quot;blue&quot;, high = &quot;red&quot;, mid = &quot;white&quot;, #definindo a escala de cor das correlações midpoint = 0, limit = c(-1,1), space = &quot;Lab&quot;, #definindo a escala das correlações name=&quot;Coef. Correlação&quot;) + #definindo o nome da legenda. theme_minimal()+ #tema de fundo do gráfico coord_fixed() + #mantém as coordenadas e as mediadas dos quadrados fixos. labs(x = &quot;nome eixo x&quot;, y = &quot;nome eixo y&quot;) #define o nome para o eixo x e para o eixo y Fique tranquilo que você não precisa decorar as funções acima. É importante que você leia e entenda o que cada uma está fazendo, só isso. E isso vai acontecer aos poucos, com a prática. Digo que você não precisa decorar porque são infinitas possibilidades e não faz sentido nenhum gastar energia decorando isso. Basta que você pesquise no Google sobre o gráfico que deseja fazer e escolha o melhor para o seu caso. Após encontrar na internet um código do gráfico que você deseja criar, basta fazer algumas adaptações para o seu caso. Entendendo os comandos do gráfico acima: assim como nos outros gráficos do pacote ggplot2, temos o padrão de inserir os dados (dados_correlacao), depois definir as variáveis para os eixos x e y e o nome da variável que será colorida (aes(Var2, Var1, fill = value)). Os comandos seguintes são as marcas de representação visual e customizações do gráfico. As mesmas estruturas acima podem ser utilizadas para todos os gráficos da biblioteca ggplot2, que possui diversos tipos de gráficos. www.luisotavio.pro "]
]
